/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example_small.py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  4 09:04:31 2021

@author: manzand
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=100)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarsmall')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(64, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 16, 3, 1),
        norm(16),
        nn.ReLU(inplace=True),
        nn.Conv2d(16, 16, 4, 2, 1),
        norm(16),
        nn.ReLU(inplace=True),
        nn.Conv2d(16, 16, 4, 2, 1),
        norm(16),
        nn.ReLU(inplace=True),
        Flatten(),
    ]


    feature_layers = [ODEBlock(ODEfunc(784))] 
    fc_layers = [nn.Linear(784, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_small.mat",nn1)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=100, network='odenet', save='../logs/cifarsmall', test_batch_size=1000, tol=0.001)
Sequential(
  (0): Conv2d(3, 16, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(16, eps=16, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): Conv2d(16, 16, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (4): BatchNorm2d(16, eps=16, momentum=0.1, affine=True, track_running_stats=True)
  (5): ReLU(inplace=True)
  (6): Conv2d(16, 16, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (7): BatchNorm2d(16, eps=16, momentum=0.1, affine=True, track_running_stats=True)
  (8): ReLU(inplace=True)
  (9): Flatten()
  (10): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=784, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=784, bias=True)
    )
  )
  (11): Linear(in_features=784, out_features=10, bias=True)
)
Number of parameters: 42506
Epoch 0000 | Time 0.440 (0.440) | NFE-F 26.0 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0001 | Time 0.391 (0.221) | NFE-F 20.7 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0002 | Time 0.869 (0.193) | NFE-F 20.3 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0003 | Time 0.357 (0.181) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0004 | Time 0.335 (0.188) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0005 | Time 0.352 (0.188) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.0987 | Test Acc 0.0993
Epoch 0006 | Time 0.291 (0.139) | NFE-F 15.8 | NFE-B 0.0 | Train Acc 0.1760 | Test Acc 0.1759
Epoch 0007 | Time 0.433 (0.181) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.2715 | Test Acc 0.2781
Epoch 0008 | Time 0.390 (0.190) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.2855 | Test Acc 0.2895
Epoch 0009 | Time 0.358 (0.196) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.3321 | Test Acc 0.3336
Epoch 0010 | Time 0.277 (0.149) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.3685 | Test Acc 0.3692
Epoch 0011 | Time 0.401 (0.152) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.3991 | Test Acc 0.4051
Epoch 0012 | Time 0.315 (0.115) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.4321 | Test Acc 0.4262
Epoch 0013 | Time 0.358 (0.130) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.4519 | Test Acc 0.4478
Epoch 0014 | Time 0.352 (0.128) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.4684 | Test Acc 0.4635
Epoch 0015 | Time 0.503 (0.202) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.4779 | Test Acc 0.4727
Epoch 0016 | Time 0.540 (0.190) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.4898 | Test Acc 0.4812
Epoch 0017 | Time 0.249 (0.126) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.5020 | Test Acc 0.4853
Epoch 0018 | Time 0.403 (0.181) | NFE-F 16.2 | NFE-B 0.0 | Train Acc 0.5150 | Test Acc 0.4966
Epoch 0019 | Time 0.383 (0.216) | NFE-F 20.1 | NFE-B 0.0 | Train Acc 0.5280 | Test Acc 0.5113
Epoch 0020 | Time 0.330 (0.178) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.5370 | Test Acc 0.5204
Epoch 0021 | Time 0.320 (0.162) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.5451 | Test Acc 0.5211
Epoch 0022 | Time 0.435 (0.173) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.5620 | Test Acc 0.5336
Epoch 0023 | Time 0.613 (0.181) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.5648 | Test Acc 0.5422
Epoch 0024 | Time 0.361 (0.162) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.5720 | Test Acc 0.5458
Epoch 0025 | Time 0.294 (0.165) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.5819 | Test Acc 0.5518
Epoch 0026 | Time 0.375 (0.180) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.5844 | Test Acc 0.5588
Epoch 0027 | Time 0.390 (0.157) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.6033 | Test Acc 0.5755
Epoch 0028 | Time 0.327 (0.155) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.6088 | Test Acc 0.5764
Epoch 0029 | Time 0.366 (0.155) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.6138 | Test Acc 0.5783
Epoch 0030 | Time 0.319 (0.179) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.6192 | Test Acc 0.5853
Epoch 0031 | Time 0.316 (0.167) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.6258 | Test Acc 0.5917
Epoch 0032 | Time 0.422 (0.280) | NFE-F 21.5 | NFE-B 0.0 | Train Acc 0.6310 | Test Acc 0.5962
Epoch 0033 | Time 0.412 (0.203) | NFE-F 25.9 | NFE-B 0.0 | Train Acc 0.6417 | Test Acc 0.5991
Epoch 0034 | Time 0.356 (0.198) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.6464 | Test Acc 0.6066
Epoch 0035 | Time 0.372 (0.180) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.6496 | Test Acc 0.6143
Epoch 0036 | Time 0.553 (0.232) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.6614 | Test Acc 0.6229
Epoch 0037 | Time 0.353 (0.199) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.6640 | Test Acc 0.6237
Epoch 0038 | Time 0.319 (0.206) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.6687 | Test Acc 0.6242
Epoch 0039 | Time 0.525 (0.254) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.6666 | Test Acc 0.6246
Epoch 0040 | Time 0.629 (0.258) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.6733 | Test Acc 0.6290
Epoch 0041 | Time 0.458 (0.223) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.6768 | Test Acc 0.6295
Epoch 0042 | Time 0.401 (0.318) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.6788 | Test Acc 0.6326
Epoch 0043 | Time 0.352 (0.207) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.6837 | Test Acc 0.6313
Epoch 0044 | Time 0.552 (0.207) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.6763 | Test Acc 0.6308
Epoch 0045 | Time 0.321 (0.219) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.6898 | Test Acc 0.6402
Epoch 0046 | Time 0.282 (0.230) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.6935 | Test Acc 0.6431
Epoch 0047 | Time 0.373 (0.186) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.6963 | Test Acc 0.6423
Epoch 0048 | Time 0.488 (0.199) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.6957 | Test Acc 0.6426
Epoch 0049 | Time 0.429 (0.273) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.6960 | Test Acc 0.6417
Epoch 0050 | Time 0.404 (0.215) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7027 | Test Acc 0.6475
Epoch 0051 | Time 0.430 (0.182) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7009 | Test Acc 0.6450
Epoch 0052 | Time 0.299 (0.232) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7012 | Test Acc 0.6461
Epoch 0053 | Time 0.369 (0.226) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7074 | Test Acc 0.6540
Epoch 0054 | Time 0.423 (0.207) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7113 | Test Acc 0.6524
Epoch 0055 | Time 0.340 (0.176) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7115 | Test Acc 0.6534
Epoch 0056 | Time 0.395 (0.192) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7147 | Test Acc 0.6540
Epoch 0057 | Time 0.365 (0.219) | NFE-F 26.8 | NFE-B 0.0 | Train Acc 0.7156 | Test Acc 0.6578
Epoch 0058 | Time 0.340 (0.175) | NFE-F 27.2 | NFE-B 0.0 | Train Acc 0.7164 | Test Acc 0.6511
Epoch 0059 | Time 0.657 (0.213) | NFE-F 28.0 | NFE-B 0.0 | Train Acc 0.7207 | Test Acc 0.6590
Epoch 0060 | Time 0.380 (0.219) | NFE-F 31.1 | NFE-B 0.0 | Train Acc 0.7210 | Test Acc 0.6585
Epoch 0061 | Time 0.452 (0.229) | NFE-F 32.1 | NFE-B 0.0 | Train Acc 0.7360 | Test Acc 0.6708
Epoch 0062 | Time 0.532 (0.264) | NFE-F 29.9 | NFE-B 0.0 | Train Acc 0.7365 | Test Acc 0.6704
Epoch 0063 | Time 0.383 (0.222) | NFE-F 27.9 | NFE-B 0.0 | Train Acc 0.7371 | Test Acc 0.6697
Epoch 0064 | Time 0.389 (0.200) | NFE-F 26.5 | NFE-B 0.0 | Train Acc 0.7376 | Test Acc 0.6694
Epoch 0065 | Time 0.336 (0.185) | NFE-F 26.4 | NFE-B 0.0 | Train Acc 0.7370 | Test Acc 0.6693
Epoch 0066 | Time 0.419 (0.220) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7384 | Test Acc 0.6685
Epoch 0067 | Time 0.353 (0.195) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7383 | Test Acc 0.6675
Epoch 0068 | Time 0.593 (0.215) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7384 | Test Acc 0.6705
Epoch 0069 | Time 0.216 (0.190) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7392 | Test Acc 0.6685
Epoch 0070 | Time 0.205 (0.106) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7385 | Test Acc 0.6697
Epoch 0071 | Time 0.575 (0.214) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7396 | Test Acc 0.6680
Epoch 0072 | Time 0.351 (0.221) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7402 | Test Acc 0.6680
Epoch 0073 | Time 0.423 (0.215) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7406 | Test Acc 0.6699
Epoch 0074 | Time 0.362 (0.202) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7405 | Test Acc 0.6678
Epoch 0075 | Time 0.345 (0.211) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7402 | Test Acc 0.6692
Epoch 0076 | Time 0.402 (0.257) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7408 | Test Acc 0.6689
Epoch 0077 | Time 0.609 (0.268) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7414 | Test Acc 0.6680
Epoch 0078 | Time 0.259 (0.129) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7414 | Test Acc 0.6686
Epoch 0079 | Time 0.470 (0.260) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7414 | Test Acc 0.6694
Epoch 0080 | Time 0.459 (0.256) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7414 | Test Acc 0.6688
Epoch 0081 | Time 0.400 (0.204) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7409 | Test Acc 0.6657
Epoch 0082 | Time 0.526 (0.286) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7426 | Test Acc 0.6699
Epoch 0083 | Time 0.518 (0.275) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7419 | Test Acc 0.6690
Epoch 0084 | Time 0.626 (0.283) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7428 | Test Acc 0.6675
Epoch 0085 | Time 0.518 (0.271) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7441 | Test Acc 0.6682
Epoch 0086 | Time 0.524 (0.322) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7438 | Test Acc 0.6689
Epoch 0087 | Time 0.552 (0.275) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7447 | Test Acc 0.6690
Epoch 0088 | Time 0.614 (0.267) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7457 | Test Acc 0.6691
Epoch 0089 | Time 0.509 (0.276) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7444 | Test Acc 0.6659
Epoch 0090 | Time 0.414 (0.275) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7449 | Test Acc 0.6705
Epoch 0091 | Time 0.359 (0.201) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7454 | Test Acc 0.6682
Epoch 0092 | Time 0.436 (0.204) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7451 | Test Acc 0.6685
Epoch 0093 | Time 0.535 (0.215) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7453 | Test Acc 0.6696
Epoch 0094 | Time 0.401 (0.191) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7464 | Test Acc 0.6683
Epoch 0095 | Time 0.414 (0.190) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7450 | Test Acc 0.6687
Epoch 0096 | Time 0.383 (0.200) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7458 | Test Acc 0.6676
Epoch 0097 | Time 0.426 (0.185) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7472 | Test Acc 0.6674
Epoch 0098 | Time 0.370 (0.193) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7473 | Test Acc 0.6677
Epoch 0099 | Time 0.429 (0.207) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7463 | Test Acc 0.6661
/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example_small.py
/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example_small.py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  4 09:04:31 2021

@author: manzand
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=200)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarsmall')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(64, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 16, 3, 1),
        norm(16),
        nn.ReLU(inplace=True),
        nn.Conv2d(16, 16, 4, 2, 1),
        norm(16),
        nn.ReLU(inplace=True),
        nn.Conv2d(16, 16, 4, 2, 1),
        norm(16),
        nn.ReLU(inplace=True),
        Flatten(),
    ]


    feature_layers = [ODEBlock(ODEfunc(784))] 
    fc_layers = [nn.Linear(784, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_small.mat",nn1)
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  4 09:04:31 2021

@author: manzand
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=200)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarsmall')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(64, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 16, 3, 1),
        norm(16),
        nn.ReLU(inplace=True),
        nn.Conv2d(16, 16, 4, 2, 1),
        norm(16),
        nn.ReLU(inplace=True),
        nn.Conv2d(16, 16, 4, 2, 1),
        norm(16),
        nn.ReLU(inplace=True),
        Flatten(),
    ]


    feature_layers = [ODEBlock(ODEfunc(784))] 
    fc_layers = [nn.Linear(784, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_small.mat",nn1)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=200, network='odenet', save='../logs/cifarsmall', test_batch_size=1000, tol=0.001)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=200, network='odenet', save='../logs/cifarsmall', test_batch_size=1000, tol=0.001)
Sequential(
  (0): Conv2d(3, 16, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(16, eps=16, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): Conv2d(16, 16, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (4): BatchNorm2d(16, eps=16, momentum=0.1, affine=True, track_running_stats=True)
  (5): ReLU(inplace=True)
  (6): Conv2d(16, 16, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (7): BatchNorm2d(16, eps=16, momentum=0.1, affine=True, track_running_stats=True)
  (8): ReLU(inplace=True)
  (9): Flatten()
  (10): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=784, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=784, bias=True)
    )
  )
  (11): Linear(in_features=784, out_features=10, bias=True)
)
Sequential(
  (0): Conv2d(3, 16, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(16, eps=16, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): Conv2d(16, 16, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (4): BatchNorm2d(16, eps=16, momentum=0.1, affine=True, track_running_stats=True)
  (5): ReLU(inplace=True)
  (6): Conv2d(16, 16, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (7): BatchNorm2d(16, eps=16, momentum=0.1, affine=True, track_running_stats=True)
  (8): ReLU(inplace=True)
  (9): Flatten()
  (10): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=784, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=784, bias=True)
    )
  )
  (11): Linear(in_features=784, out_features=10, bias=True)
)
Number of parameters: 42506
Number of parameters: 42506
Epoch 0000 | Time 0.340 (0.340) | NFE-F 26.0 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0000 | Time 0.340 (0.340) | NFE-F 26.0 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0001 | Time 0.363 (0.182) | NFE-F 20.4 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0001 | Time 0.363 (0.182) | NFE-F 20.4 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0002 | Time 0.368 (0.170) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0002 | Time 0.368 (0.170) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0003 | Time 0.328 (0.145) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0003 | Time 0.328 (0.145) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0004 | Time 0.342 (0.172) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0004 | Time 0.342 (0.172) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0005 | Time 0.591 (0.170) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.1124 | Test Acc 0.1132
Epoch 0005 | Time 0.591 (0.170) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.1124 | Test Acc 0.1132
Epoch 0006 | Time 0.305 (0.129) | NFE-F 14.5 | NFE-B 0.0 | Train Acc 0.2701 | Test Acc 0.2809
Epoch 0006 | Time 0.305 (0.129) | NFE-F 14.5 | NFE-B 0.0 | Train Acc 0.2701 | Test Acc 0.2809
Epoch 0007 | Time 0.377 (0.138) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.2803 | Test Acc 0.2814
Epoch 0007 | Time 0.377 (0.138) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.2803 | Test Acc 0.2814
Epoch 0008 | Time 0.325 (0.119) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.3038 | Test Acc 0.3069
Epoch 0008 | Time 0.325 (0.119) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.3038 | Test Acc 0.3069
Epoch 0009 | Time 0.319 (0.136) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.3434 | Test Acc 0.3466
Epoch 0009 | Time 0.319 (0.136) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.3434 | Test Acc 0.3466
Epoch 0010 | Time 0.332 (0.132) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.3795 | Test Acc 0.3772
Epoch 0010 | Time 0.332 (0.132) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.3795 | Test Acc 0.3772
Epoch 0011 | Time 0.305 (0.122) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.4055 | Test Acc 0.4106
Epoch 0011 | Time 0.305 (0.122) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.4055 | Test Acc 0.4106
Epoch 0012 | Time 0.351 (0.155) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.4389 | Test Acc 0.4381
Epoch 0012 | Time 0.351 (0.155) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.4389 | Test Acc 0.4381
Epoch 0013 | Time 0.307 (0.135) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.4625 | Test Acc 0.4616
Epoch 0013 | Time 0.307 (0.135) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.4625 | Test Acc 0.4616
Epoch 0014 | Time 0.314 (0.135) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.4886 | Test Acc 0.4861
Epoch 0014 | Time 0.314 (0.135) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.4886 | Test Acc 0.4861
Epoch 0015 | Time 0.341 (0.135) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.5016 | Test Acc 0.4955
Epoch 0015 | Time 0.341 (0.135) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.5016 | Test Acc 0.4955
Epoch 0016 | Time 0.313 (0.122) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.5321 | Test Acc 0.5206
Epoch 0016 | Time 0.313 (0.122) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.5321 | Test Acc 0.5206
Epoch 0017 | Time 0.274 (0.137) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.5466 | Test Acc 0.5354
Epoch 0017 | Time 0.274 (0.137) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.5466 | Test Acc 0.5354
Epoch 0018 | Time 0.344 (0.138) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.5591 | Test Acc 0.5406
Epoch 0018 | Time 0.344 (0.138) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.5591 | Test Acc 0.5406
Epoch 0019 | Time 0.313 (0.146) | NFE-F 17.1 | NFE-B 0.0 | Train Acc 0.5679 | Test Acc 0.5526
Epoch 0019 | Time 0.313 (0.146) | NFE-F 17.1 | NFE-B 0.0 | Train Acc 0.5679 | Test Acc 0.5526
Epoch 0020 | Time 0.377 (0.176) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.5809 | Test Acc 0.5651
Epoch 0020 | Time 0.377 (0.176) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.5809 | Test Acc 0.5651
Epoch 0021 | Time 0.309 (0.163) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.5932 | Test Acc 0.5722
Epoch 0021 | Time 0.309 (0.163) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.5932 | Test Acc 0.5722
Epoch 0022 | Time 0.335 (0.163) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.5988 | Test Acc 0.5750
Epoch 0022 | Time 0.335 (0.163) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.5988 | Test Acc 0.5750
Epoch 0023 | Time 0.324 (0.168) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.6221 | Test Acc 0.5987
Epoch 0023 | Time 0.324 (0.168) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.6221 | Test Acc 0.5987
Epoch 0024 | Time 0.350 (0.164) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.6261 | Test Acc 0.5962
Epoch 0024 | Time 0.350 (0.164) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.6261 | Test Acc 0.5962
Epoch 0025 | Time 0.353 (0.156) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.6332 | Test Acc 0.6021
Epoch 0025 | Time 0.353 (0.156) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.6332 | Test Acc 0.6021
Epoch 0026 | Time 0.328 (0.161) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.6366 | Test Acc 0.6054
Epoch 0026 | Time 0.328 (0.161) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.6366 | Test Acc 0.6054
Epoch 0027 | Time 0.329 (0.167) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.6521 | Test Acc 0.6118
Epoch 0027 | Time 0.329 (0.167) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.6521 | Test Acc 0.6118
Epoch 0028 | Time 0.379 (0.158) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.6569 | Test Acc 0.6235
Epoch 0028 | Time 0.379 (0.158) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.6569 | Test Acc 0.6235
Epoch 0029 | Time 0.325 (0.160) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.6620 | Test Acc 0.6269
Epoch 0029 | Time 0.325 (0.160) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.6620 | Test Acc 0.6269
Epoch 0030 | Time 0.430 (0.168) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.6660 | Test Acc 0.6277
Epoch 0030 | Time 0.430 (0.168) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.6660 | Test Acc 0.6277
Epoch 0031 | Time 0.390 (0.171) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.6705 | Test Acc 0.6265
Epoch 0031 | Time 0.390 (0.171) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.6705 | Test Acc 0.6265
Epoch 0032 | Time 0.399 (0.154) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.6723 | Test Acc 0.6328
Epoch 0032 | Time 0.399 (0.154) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.6723 | Test Acc 0.6328
Epoch 0033 | Time 0.341 (0.163) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.6695 | Test Acc 0.6288
Epoch 0033 | Time 0.341 (0.163) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.6695 | Test Acc 0.6288
Epoch 0034 | Time 0.398 (0.161) | NFE-F 20.5 | NFE-B 0.0 | Train Acc 0.6802 | Test Acc 0.6406
Epoch 0034 | Time 0.398 (0.161) | NFE-F 20.5 | NFE-B 0.0 | Train Acc 0.6802 | Test Acc 0.6406
Epoch 0035 | Time 0.386 (0.186) | NFE-F 21.8 | NFE-B 0.0 | Train Acc 0.6863 | Test Acc 0.6429
Epoch 0035 | Time 0.386 (0.186) | NFE-F 21.8 | NFE-B 0.0 | Train Acc 0.6863 | Test Acc 0.6429
Epoch 0036 | Time 0.470 (0.201) | NFE-F 25.8 | NFE-B 0.0 | Train Acc 0.6866 | Test Acc 0.6381
Epoch 0036 | Time 0.470 (0.201) | NFE-F 25.8 | NFE-B 0.0 | Train Acc 0.6866 | Test Acc 0.6381
Epoch 0037 | Time 0.422 (0.195) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.6946 | Test Acc 0.6481
Epoch 0037 | Time 0.422 (0.195) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.6946 | Test Acc 0.6481
Epoch 0038 | Time 0.451 (0.192) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.6943 | Test Acc 0.6465
Epoch 0038 | Time 0.451 (0.192) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.6943 | Test Acc 0.6465
Epoch 0039 | Time 0.376 (0.190) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7042 | Test Acc 0.6561
Epoch 0039 | Time 0.376 (0.190) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7042 | Test Acc 0.6561
Epoch 0040 | Time 0.406 (0.193) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7065 | Test Acc 0.6558
Epoch 0040 | Time 0.406 (0.193) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7065 | Test Acc 0.6558
Epoch 0041 | Time 0.393 (0.205) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7086 | Test Acc 0.6541
Epoch 0041 | Time 0.393 (0.205) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7086 | Test Acc 0.6541
Epoch 0042 | Time 0.483 (0.216) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7114 | Test Acc 0.6604
Epoch 0042 | Time 0.483 (0.216) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7114 | Test Acc 0.6604
Epoch 0043 | Time 0.406 (0.211) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7119 | Test Acc 0.6588
Epoch 0043 | Time 0.406 (0.211) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7119 | Test Acc 0.6588
Epoch 0044 | Time 0.393 (0.214) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7173 | Test Acc 0.6623
Epoch 0044 | Time 0.393 (0.214) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7173 | Test Acc 0.6623
Epoch 0045 | Time 0.422 (0.188) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7145 | Test Acc 0.6566
Epoch 0045 | Time 0.422 (0.188) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7145 | Test Acc 0.6566
Epoch 0046 | Time 0.344 (0.190) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7190 | Test Acc 0.6651
Epoch 0046 | Time 0.344 (0.190) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7190 | Test Acc 0.6651
Epoch 0047 | Time 0.393 (0.190) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7317 | Test Acc 0.6680
Epoch 0047 | Time 0.393 (0.190) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7317 | Test Acc 0.6680
Epoch 0048 | Time 0.409 (0.205) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7280 | Test Acc 0.6639
Epoch 0048 | Time 0.409 (0.205) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7280 | Test Acc 0.6639
Epoch 0049 | Time 0.404 (0.185) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7257 | Test Acc 0.6641
Epoch 0049 | Time 0.404 (0.185) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7257 | Test Acc 0.6641
Epoch 0050 | Time 0.347 (0.205) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7337 | Test Acc 0.6662
Epoch 0050 | Time 0.347 (0.205) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7337 | Test Acc 0.6662
Epoch 0051 | Time 0.411 (0.216) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7292 | Test Acc 0.6665
Epoch 0051 | Time 0.411 (0.216) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7292 | Test Acc 0.6665
Epoch 0052 | Time 0.425 (0.213) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7341 | Test Acc 0.6679
Epoch 0052 | Time 0.425 (0.213) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7341 | Test Acc 0.6679
Epoch 0053 | Time 0.453 (0.203) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7329 | Test Acc 0.6689
Epoch 0053 | Time 0.453 (0.203) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7329 | Test Acc 0.6689
Epoch 0054 | Time 0.372 (0.191) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7376 | Test Acc 0.6665
Epoch 0054 | Time 0.372 (0.191) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7376 | Test Acc 0.6665
Epoch 0055 | Time 0.461 (0.186) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7432 | Test Acc 0.6737
Epoch 0055 | Time 0.461 (0.186) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7432 | Test Acc 0.6737
Epoch 0056 | Time 0.408 (0.198) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7470 | Test Acc 0.6734
Epoch 0056 | Time 0.408 (0.198) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7470 | Test Acc 0.6734
Epoch 0057 | Time 0.466 (0.203) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7410 | Test Acc 0.6671
Epoch 0057 | Time 0.466 (0.203) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7410 | Test Acc 0.6671
Epoch 0058 | Time 0.435 (0.203) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7472 | Test Acc 0.6736
Epoch 0058 | Time 0.435 (0.203) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7472 | Test Acc 0.6736
Epoch 0059 | Time 0.377 (0.197) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7462 | Test Acc 0.6716
Epoch 0059 | Time 0.377 (0.197) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7462 | Test Acc 0.6716
Epoch 0060 | Time 0.368 (0.216) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7485 | Test Acc 0.6711
Epoch 0060 | Time 0.368 (0.216) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7485 | Test Acc 0.6711
Epoch 0061 | Time 0.390 (0.211) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7599 | Test Acc 0.6815
Epoch 0061 | Time 0.390 (0.211) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7599 | Test Acc 0.6815
Epoch 0062 | Time 0.541 (0.204) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7612 | Test Acc 0.6814
Epoch 0062 | Time 0.541 (0.204) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7612 | Test Acc 0.6814
Epoch 0063 | Time 0.366 (0.193) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7614 | Test Acc 0.6799
Epoch 0063 | Time 0.366 (0.193) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7614 | Test Acc 0.6799
Epoch 0064 | Time 0.408 (0.174) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7622 | Test Acc 0.6796
Epoch 0064 | Time 0.408 (0.174) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7622 | Test Acc 0.6796
Epoch 0065 | Time 0.411 (0.196) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7621 | Test Acc 0.6781
Epoch 0065 | Time 0.411 (0.196) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7621 | Test Acc 0.6781
Epoch 0066 | Time 0.421 (0.196) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7626 | Test Acc 0.6803
Epoch 0066 | Time 0.421 (0.196) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7626 | Test Acc 0.6803
Epoch 0067 | Time 0.403 (0.201) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7638 | Test Acc 0.6790
Epoch 0067 | Time 0.403 (0.201) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7638 | Test Acc 0.6790
Epoch 0068 | Time 0.452 (0.204) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7635 | Test Acc 0.6788
Epoch 0068 | Time 0.452 (0.204) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7635 | Test Acc 0.6788
Epoch 0069 | Time 0.464 (0.203) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7636 | Test Acc 0.6797
Epoch 0069 | Time 0.464 (0.203) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7636 | Test Acc 0.6797
Epoch 0070 | Time 0.421 (0.181) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7638 | Test Acc 0.6781
Epoch 0070 | Time 0.421 (0.181) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7638 | Test Acc 0.6781
Epoch 0071 | Time 0.397 (0.197) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7651 | Test Acc 0.6774
Epoch 0071 | Time 0.397 (0.197) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7651 | Test Acc 0.6774
Epoch 0072 | Time 0.384 (0.207) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7620 | Test Acc 0.6759
Epoch 0072 | Time 0.384 (0.207) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7620 | Test Acc 0.6759
Epoch 0073 | Time 0.402 (0.196) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7632 | Test Acc 0.6770
Epoch 0073 | Time 0.402 (0.196) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7632 | Test Acc 0.6770
Epoch 0074 | Time 0.364 (0.199) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7652 | Test Acc 0.6802
Epoch 0074 | Time 0.364 (0.199) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7652 | Test Acc 0.6802
Epoch 0075 | Time 0.396 (0.205) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7651 | Test Acc 0.6785
Epoch 0075 | Time 0.396 (0.205) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7651 | Test Acc 0.6785
Epoch 0076 | Time 0.351 (0.194) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7644 | Test Acc 0.6762
Epoch 0076 | Time 0.351 (0.194) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7644 | Test Acc 0.6762
Epoch 0077 | Time 0.342 (0.212) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7645 | Test Acc 0.6790
Epoch 0077 | Time 0.342 (0.212) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7645 | Test Acc 0.6790
Epoch 0078 | Time 0.205 (0.147) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7660 | Test Acc 0.6771
Epoch 0078 | Time 0.205 (0.147) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7660 | Test Acc 0.6771
Epoch 0079 | Time 0.203 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7659 | Test Acc 0.6792
Epoch 0079 | Time 0.203 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7659 | Test Acc 0.6792
Epoch 0080 | Time 0.214 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7649 | Test Acc 0.6756
Epoch 0080 | Time 0.214 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7649 | Test Acc 0.6756
Epoch 0081 | Time 0.206 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7658 | Test Acc 0.6795
Epoch 0081 | Time 0.206 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7658 | Test Acc 0.6795
Epoch 0082 | Time 0.201 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7666 | Test Acc 0.6784
Epoch 0082 | Time 0.201 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7666 | Test Acc 0.6784
Epoch 0083 | Time 0.202 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7674 | Test Acc 0.6795
Epoch 0083 | Time 0.202 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7674 | Test Acc 0.6795
Epoch 0084 | Time 0.221 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7666 | Test Acc 0.6796
Epoch 0084 | Time 0.221 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7666 | Test Acc 0.6796
Epoch 0085 | Time 0.206 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7674 | Test Acc 0.6753
Epoch 0085 | Time 0.206 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7674 | Test Acc 0.6753
Epoch 0086 | Time 0.205 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7679 | Test Acc 0.6776
Epoch 0086 | Time 0.205 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7679 | Test Acc 0.6776
Epoch 0087 | Time 0.208 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7674 | Test Acc 0.6791
Epoch 0087 | Time 0.208 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7674 | Test Acc 0.6791
Epoch 0088 | Time 0.209 (0.098) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7673 | Test Acc 0.6762
Epoch 0088 | Time 0.209 (0.098) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7673 | Test Acc 0.6762
Epoch 0089 | Time 0.220 (0.099) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7662 | Test Acc 0.6779
Epoch 0089 | Time 0.220 (0.099) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7662 | Test Acc 0.6779
Epoch 0090 | Time 0.203 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7680 | Test Acc 0.6743
Epoch 0090 | Time 0.203 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7680 | Test Acc 0.6743
Epoch 0091 | Time 0.198 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7683 | Test Acc 0.6766
Epoch 0091 | Time 0.198 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7683 | Test Acc 0.6766
Epoch 0092 | Time 0.219 (0.095) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7688 | Test Acc 0.6775
Epoch 0092 | Time 0.219 (0.095) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7688 | Test Acc 0.6775
Epoch 0093 | Time 0.213 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7686 | Test Acc 0.6774
Epoch 0093 | Time 0.213 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7686 | Test Acc 0.6774
Epoch 0094 | Time 0.199 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7684 | Test Acc 0.6755
Epoch 0094 | Time 0.199 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7684 | Test Acc 0.6755
Epoch 0095 | Time 0.216 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7689 | Test Acc 0.6782
Epoch 0095 | Time 0.216 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7689 | Test Acc 0.6782
Epoch 0096 | Time 0.211 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7692 | Test Acc 0.6796
Epoch 0096 | Time 0.211 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7692 | Test Acc 0.6796
Epoch 0097 | Time 0.218 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7688 | Test Acc 0.6756
Epoch 0097 | Time 0.218 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7688 | Test Acc 0.6756
Epoch 0098 | Time 0.210 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7704 | Test Acc 0.6802
Epoch 0098 | Time 0.210 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7704 | Test Acc 0.6802
Epoch 0099 | Time 0.206 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7690 | Test Acc 0.6768
Epoch 0099 | Time 0.206 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7690 | Test Acc 0.6768
Epoch 0100 | Time 0.195 (0.098) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7689 | Test Acc 0.6786
Epoch 0100 | Time 0.195 (0.098) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7689 | Test Acc 0.6786
Epoch 0101 | Time 0.210 (0.100) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7711 | Test Acc 0.6780
Epoch 0101 | Time 0.210 (0.100) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7711 | Test Acc 0.6780
Epoch 0102 | Time 0.235 (0.100) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7712 | Test Acc 0.6786
Epoch 0102 | Time 0.235 (0.100) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7712 | Test Acc 0.6786
Epoch 0103 | Time 0.206 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7710 | Test Acc 0.6783
Epoch 0103 | Time 0.206 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7710 | Test Acc 0.6783
Epoch 0104 | Time 0.197 (0.095) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7708 | Test Acc 0.6777
Epoch 0104 | Time 0.197 (0.095) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7708 | Test Acc 0.6777
Epoch 0105 | Time 0.206 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7710 | Test Acc 0.6780
Epoch 0105 | Time 0.206 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7710 | Test Acc 0.6780
Epoch 0106 | Time 0.198 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7714 | Test Acc 0.6780
Epoch 0106 | Time 0.198 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7714 | Test Acc 0.6780
Epoch 0107 | Time 0.215 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7718 | Test Acc 0.6777
Epoch 0107 | Time 0.215 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7718 | Test Acc 0.6777
Epoch 0108 | Time 0.196 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7718 | Test Acc 0.6783
Epoch 0108 | Time 0.196 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7718 | Test Acc 0.6783
Epoch 0109 | Time 0.200 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7714 | Test Acc 0.6785
Epoch 0109 | Time 0.200 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7714 | Test Acc 0.6785
Epoch 0110 | Time 0.203 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7712 | Test Acc 0.6784
Epoch 0110 | Time 0.203 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7712 | Test Acc 0.6784
Epoch 0111 | Time 0.206 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7713 | Test Acc 0.6778
Epoch 0111 | Time 0.206 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7713 | Test Acc 0.6778
Epoch 0112 | Time 0.203 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7712 | Test Acc 0.6777
Epoch 0112 | Time 0.203 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7712 | Test Acc 0.6777
Epoch 0113 | Time 0.191 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7714 | Test Acc 0.6783
Epoch 0113 | Time 0.191 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7714 | Test Acc 0.6783
Epoch 0114 | Time 0.196 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7719 | Test Acc 0.6782
Epoch 0114 | Time 0.196 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7719 | Test Acc 0.6782
Epoch 0115 | Time 0.219 (0.099) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7712 | Test Acc 0.6779
Epoch 0115 | Time 0.219 (0.099) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7712 | Test Acc 0.6779
Epoch 0116 | Time 0.203 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7717 | Test Acc 0.6775
Epoch 0116 | Time 0.203 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7717 | Test Acc 0.6775
Epoch 0117 | Time 0.199 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7715 | Test Acc 0.6774
Epoch 0117 | Time 0.199 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7715 | Test Acc 0.6774
Epoch 0118 | Time 0.216 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7714 | Test Acc 0.6782
Epoch 0118 | Time 0.216 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7714 | Test Acc 0.6782
Epoch 0119 | Time 0.198 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7720 | Test Acc 0.6777
Epoch 0119 | Time 0.198 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7720 | Test Acc 0.6777
Epoch 0120 | Time 0.200 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7715 | Test Acc 0.6781
Epoch 0120 | Time 0.200 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7715 | Test Acc 0.6781
Epoch 0121 | Time 0.214 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7715 | Test Acc 0.6778
Epoch 0121 | Time 0.214 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7715 | Test Acc 0.6778
Epoch 0122 | Time 0.204 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7718 | Test Acc 0.6778
Epoch 0122 | Time 0.204 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7718 | Test Acc 0.6778
Epoch 0123 | Time 0.197 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7714 | Test Acc 0.6773
Epoch 0123 | Time 0.197 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7714 | Test Acc 0.6773
Epoch 0124 | Time 0.196 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7714 | Test Acc 0.6774
Epoch 0124 | Time 0.196 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7714 | Test Acc 0.6774
Epoch 0125 | Time 0.203 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7714 | Test Acc 0.6774
Epoch 0125 | Time 0.203 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7714 | Test Acc 0.6774
Epoch 0126 | Time 0.212 (0.099) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7720 | Test Acc 0.6776
Epoch 0126 | Time 0.212 (0.099) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7720 | Test Acc 0.6776
Epoch 0127 | Time 0.207 (0.098) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7716 | Test Acc 0.6772
Epoch 0127 | Time 0.207 (0.098) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7716 | Test Acc 0.6772
Epoch 0128 | Time 0.211 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7720 | Test Acc 0.6776
Epoch 0128 | Time 0.211 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7720 | Test Acc 0.6776
Epoch 0129 | Time 0.220 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7720 | Test Acc 0.6773
Epoch 0129 | Time 0.220 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7720 | Test Acc 0.6773
Epoch 0130 | Time 0.207 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7717 | Test Acc 0.6782
Epoch 0130 | Time 0.207 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7717 | Test Acc 0.6782
Epoch 0131 | Time 0.199 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7719 | Test Acc 0.6772
Epoch 0131 | Time 0.199 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7719 | Test Acc 0.6772
Epoch 0132 | Time 0.208 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7722 | Test Acc 0.6776
Epoch 0132 | Time 0.208 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7722 | Test Acc 0.6776
Epoch 0133 | Time 0.216 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7722 | Test Acc 0.6773
Epoch 0133 | Time 0.216 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7722 | Test Acc 0.6773
Epoch 0134 | Time 0.206 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7718 | Test Acc 0.6775
Epoch 0134 | Time 0.206 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7718 | Test Acc 0.6775
Epoch 0135 | Time 0.195 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7719 | Test Acc 0.6782
Epoch 0135 | Time 0.195 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7719 | Test Acc 0.6782
Epoch 0136 | Time 0.207 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7718 | Test Acc 0.6764
Epoch 0136 | Time 0.207 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7718 | Test Acc 0.6764
Epoch 0137 | Time 0.200 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7719 | Test Acc 0.6772
Epoch 0137 | Time 0.200 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7719 | Test Acc 0.6772
Epoch 0138 | Time 0.219 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7719 | Test Acc 0.6759
Epoch 0138 | Time 0.219 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7719 | Test Acc 0.6759
Epoch 0139 | Time 0.209 (0.098) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7719 | Test Acc 0.6777
Epoch 0139 | Time 0.209 (0.098) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7719 | Test Acc 0.6777
Epoch 0140 | Time 0.195 (0.100) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7720 | Test Acc 0.6776
Epoch 0140 | Time 0.195 (0.100) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7720 | Test Acc 0.6776
Epoch 0141 | Time 0.210 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6773
Epoch 0141 | Time 0.210 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6773
Epoch 0142 | Time 0.198 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7722 | Test Acc 0.6775
Epoch 0142 | Time 0.198 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7722 | Test Acc 0.6775
Epoch 0143 | Time 0.204 (0.095) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6774
Epoch 0143 | Time 0.204 (0.095) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6774
Epoch 0144 | Time 0.203 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6778
Epoch 0144 | Time 0.203 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6778
Epoch 0145 | Time 0.201 (0.095) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6782
Epoch 0145 | Time 0.201 (0.095) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6782
Epoch 0146 | Time 0.203 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7722 | Test Acc 0.6779
Epoch 0146 | Time 0.203 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7722 | Test Acc 0.6779
Epoch 0147 | Time 0.203 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6777
Epoch 0147 | Time 0.203 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6777
Epoch 0148 | Time 0.205 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6778
Epoch 0148 | Time 0.205 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6778
Epoch 0149 | Time 0.204 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7720 | Test Acc 0.6779
Epoch 0149 | Time 0.204 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7720 | Test Acc 0.6779
Epoch 0150 | Time 0.201 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7720 | Test Acc 0.6779
Epoch 0150 | Time 0.201 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7720 | Test Acc 0.6779
Epoch 0151 | Time 0.226 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6778
Epoch 0151 | Time 0.226 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6778
Epoch 0152 | Time 0.202 (0.098) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6776
Epoch 0152 | Time 0.202 (0.098) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6776
Epoch 0153 | Time 0.197 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6779
Epoch 0153 | Time 0.197 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6779
Epoch 0154 | Time 0.199 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6775
Epoch 0154 | Time 0.199 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6775
Epoch 0155 | Time 0.199 (0.095) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6778
Epoch 0155 | Time 0.199 (0.095) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6778
Epoch 0156 | Time 0.200 (0.095) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6780
Epoch 0156 | Time 0.200 (0.095) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6780
Epoch 0157 | Time 0.199 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6783
Epoch 0157 | Time 0.199 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6783
Epoch 0158 | Time 0.202 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6780
Epoch 0158 | Time 0.202 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6780
Epoch 0159 | Time 0.208 (0.098) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6779
Epoch 0159 | Time 0.208 (0.098) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6779
Epoch 0160 | Time 0.202 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7722 | Test Acc 0.6784
Epoch 0160 | Time 0.202 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7722 | Test Acc 0.6784
Epoch 0161 | Time 0.202 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6783
Epoch 0161 | Time 0.202 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6783
Epoch 0162 | Time 0.207 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6783
Epoch 0162 | Time 0.207 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6783
Epoch 0163 | Time 0.210 (0.098) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6782
Epoch 0163 | Time 0.210 (0.098) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6782
Epoch 0164 | Time 0.208 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6782
Epoch 0164 | Time 0.208 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6782
Epoch 0165 | Time 0.209 (0.099) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6781
Epoch 0165 | Time 0.209 (0.099) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6781
Epoch 0166 | Time 0.211 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6781
Epoch 0166 | Time 0.211 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6781
Epoch 0167 | Time 0.196 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6782
Epoch 0167 | Time 0.196 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6782
Epoch 0168 | Time 0.203 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7722 | Test Acc 0.6781
Epoch 0168 | Time 0.203 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7722 | Test Acc 0.6781
Epoch 0169 | Time 0.206 (0.095) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6782
Epoch 0169 | Time 0.206 (0.095) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6782
Epoch 0170 | Time 0.213 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7722 | Test Acc 0.6782
Epoch 0170 | Time 0.213 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7722 | Test Acc 0.6782
Epoch 0171 | Time 0.198 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6781
Epoch 0171 | Time 0.198 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6781
Epoch 0172 | Time 0.197 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7722 | Test Acc 0.6782
Epoch 0172 | Time 0.197 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7722 | Test Acc 0.6782
Epoch 0173 | Time 0.200 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6781
Epoch 0173 | Time 0.200 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6781
Epoch 0174 | Time 0.203 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7722 | Test Acc 0.6781
Epoch 0174 | Time 0.203 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7722 | Test Acc 0.6781
Epoch 0175 | Time 0.220 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6783
Epoch 0175 | Time 0.220 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6783
Epoch 0176 | Time 0.210 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7722 | Test Acc 0.6781
Epoch 0176 | Time 0.210 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7722 | Test Acc 0.6781
Epoch 0177 | Time 0.203 (0.098) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7722 | Test Acc 0.6781
Epoch 0177 | Time 0.203 (0.098) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7722 | Test Acc 0.6781
Epoch 0178 | Time 0.216 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6784
Epoch 0178 | Time 0.216 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6784
Epoch 0179 | Time 0.196 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7722 | Test Acc 0.6783
Epoch 0179 | Time 0.196 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7722 | Test Acc 0.6783
Epoch 0180 | Time 0.212 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6781
Epoch 0180 | Time 0.212 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6781
Epoch 0181 | Time 0.199 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6782
Epoch 0181 | Time 0.199 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6782
Epoch 0182 | Time 0.218 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6781
Epoch 0182 | Time 0.218 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6781
Epoch 0183 | Time 0.209 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6780
Epoch 0183 | Time 0.209 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6780
Epoch 0184 | Time 0.198 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6779
Epoch 0184 | Time 0.198 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6779
Epoch 0185 | Time 0.201 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7720 | Test Acc 0.6784
Epoch 0185 | Time 0.201 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7720 | Test Acc 0.6784
Epoch 0186 | Time 0.199 (0.095) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7722 | Test Acc 0.6781
Epoch 0186 | Time 0.199 (0.095) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7722 | Test Acc 0.6781
Epoch 0187 | Time 0.191 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7722 | Test Acc 0.6782
Epoch 0187 | Time 0.191 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7722 | Test Acc 0.6782
Epoch 0188 | Time 0.211 (0.098) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7722 | Test Acc 0.6780
Epoch 0188 | Time 0.211 (0.098) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7722 | Test Acc 0.6780
Epoch 0189 | Time 0.220 (0.098) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6780
Epoch 0189 | Time 0.220 (0.098) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6780
Epoch 0190 | Time 0.211 (0.098) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7720 | Test Acc 0.6779
Epoch 0190 | Time 0.211 (0.098) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7720 | Test Acc 0.6779
Epoch 0191 | Time 0.206 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6781
Epoch 0191 | Time 0.206 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6781
Epoch 0192 | Time 0.218 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6782
Epoch 0192 | Time 0.218 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7721 | Test Acc 0.6782
Epoch 0193 | Time 0.199 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7722 | Test Acc 0.6783
Epoch 0193 | Time 0.199 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7722 | Test Acc 0.6783
Epoch 0194 | Time 0.200 (0.095) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7722 | Test Acc 0.6780
Epoch 0194 | Time 0.200 (0.095) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7722 | Test Acc 0.6780
Epoch 0195 | Time 0.202 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7722 | Test Acc 0.6780
Epoch 0195 | Time 0.202 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7722 | Test Acc 0.6780
Epoch 0196 | Time 0.204 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7723 | Test Acc 0.6779
Epoch 0196 | Time 0.204 (0.097) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7723 | Test Acc 0.6779
Epoch 0197 | Time 0.199 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7722 | Test Acc 0.6781
Epoch 0197 | Time 0.199 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7722 | Test Acc 0.6781
Epoch 0198 | Time 0.206 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7723 | Test Acc 0.6779
Epoch 0198 | Time 0.206 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7723 | Test Acc 0.6779
Epoch 0199 | Time 0.218 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7722 | Test Acc 0.6782
Epoch 0199 | Time 0.218 (0.096) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.7722 | Test Acc 0.6782
/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example.py
/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example.py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=100)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarmid')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(64, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 36, 3, 1),
        norm(36),
        nn.ReLU(inplace=True),
        nn.Conv2d(36, 24, 4, 2, 1),
        norm(24),
        nn.ReLU(inplace=True),
        nn.Conv2d(24, 16, 4, 2, 1),
        norm(16),
        nn.ReLU(inplace=True),
        Flatten(),
    ]


    # feature_layers = [ODEBlock(ODEfunc(490))] 
    # fc_layers = [nn.Linear(490, 10)]
    feature_layers = [ODEBlock(ODEfunc(2250))] 
    fc_layers = [nn.Linear(2250, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_mid.mat",nn1)
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=100)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarmid')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(64, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 36, 3, 1),
        norm(36),
        nn.ReLU(inplace=True),
        nn.Conv2d(36, 24, 4, 2, 1),
        norm(24),
        nn.ReLU(inplace=True),
        nn.Conv2d(24, 16, 4, 2, 1),
        norm(16),
        nn.ReLU(inplace=True),
        Flatten(),
    ]


    # feature_layers = [ODEBlock(ODEfunc(490))] 
    # fc_layers = [nn.Linear(490, 10)]
    feature_layers = [ODEBlock(ODEfunc(2250))] 
    fc_layers = [nn.Linear(2250, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_mid.mat",nn1)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=100, network='odenet', save='../logs/cifarmid', test_batch_size=1000, tol=0.001)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=100, network='odenet', save='../logs/cifarmid', test_batch_size=1000, tol=0.001)
Sequential(
  (0): Conv2d(3, 36, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(36, eps=36, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): Conv2d(36, 24, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (4): BatchNorm2d(24, eps=24, momentum=0.1, affine=True, track_running_stats=True)
  (5): ReLU(inplace=True)
  (6): Conv2d(24, 16, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (7): BatchNorm2d(16, eps=16, momentum=0.1, affine=True, track_running_stats=True)
  (8): ReLU(inplace=True)
  (9): Flatten()
  (10): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=2250, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=2250, bias=True)
    )
  )
  (11): Linear(in_features=2250, out_features=10, bias=True)
)
Sequential(
  (0): Conv2d(3, 36, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(36, eps=36, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): Conv2d(36, 24, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (4): BatchNorm2d(24, eps=24, momentum=0.1, affine=True, track_running_stats=True)
  (5): ReLU(inplace=True)
  (6): Conv2d(24, 16, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (7): BatchNorm2d(16, eps=16, momentum=0.1, affine=True, track_running_stats=True)
  (8): ReLU(inplace=True)
  (9): Flatten()
  (10): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=2250, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=2250, bias=True)
    )
  )
  (11): Linear(in_features=2250, out_features=10, bias=True)
)
Number of parameters: 117944
Number of parameters: 117944
/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example_small.py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  4 09:04:31 2021

@author: manzand
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=200)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarsmall')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(64, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 64, 3, 1),
        norm(64),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,2),
        nn.Conv2d(64, 128, 4, 2, 1),
        norm(128),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(128, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.Conv2d(256, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(256, 512, 4, 2, 1),
        norm(512),
        nn.ReLU(inplace = True),
        nn.Conv2d(512, 512, 4, 2, 1),
        norm(512),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        Flatten(),
    ]


    feature_layers = [ODEBlock(ODEfunc(784))] 
    fc_layers = [nn.Linear(784, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_small.mat",nn1)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=200, network='odenet', save='../logs/cifarsmall', test_batch_size=1000, tol=0.001)
Sequential(
  (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(64, eps=64, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): AvgPool2d(kernel_size=2, stride=2, padding=0)
  (4): Conv2d(64, 128, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (5): BatchNorm2d(64, eps=128, momentum=0.1, affine=True, track_running_stats=True)
  (6): ReLU(inplace=True)
  (7): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (8): Conv2d(128, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (9): BatchNorm2d(64, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (10): ReLU(inplace=True)
  (11): Conv2d(256, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (12): BatchNorm2d(64, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (13): ReLU(inplace=True)
  (14): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (15): Conv2d(256, 512, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (16): BatchNorm2d(64, eps=512, momentum=0.1, affine=True, track_running_stats=True)
  (17): ReLU(inplace=True)
  (18): Conv2d(512, 512, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (19): BatchNorm2d(64, eps=512, momentum=0.1, affine=True, track_running_stats=True)
  (20): ReLU(inplace=True)
  (21): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (22): Flatten()
  (23): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=784, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=784, bias=True)
    )
  )
  (24): Linear(in_features=784, out_features=10, bias=True)
)
Number of parameters: 8033354
/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example_small.py
/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example_small.py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  4 09:04:31 2021

@author: manzand
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=200)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarsmall')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(512, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 64, 3, 1),
        norm(64),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,2),
        nn.Conv2d(64, 128, 4, 2, 1),
        norm(128),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(128, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.Conv2d(256, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(256, 512, 4, 2, 1),
        norm(512),
        nn.ReLU(inplace = True),
        nn.Conv2d(512, 512, 4, 2, 1),
        norm(512),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        Flatten(),
    ]


    feature_layers = [ODEBlock(ODEfunc(784))] 
    fc_layers = [nn.Linear(784, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_small.mat",nn1)
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  4 09:04:31 2021

@author: manzand
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=200)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarsmall')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(512, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 64, 3, 1),
        norm(64),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,2),
        nn.Conv2d(64, 128, 4, 2, 1),
        norm(128),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(128, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.Conv2d(256, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(256, 512, 4, 2, 1),
        norm(512),
        nn.ReLU(inplace = True),
        nn.Conv2d(512, 512, 4, 2, 1),
        norm(512),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        Flatten(),
    ]


    feature_layers = [ODEBlock(ODEfunc(784))] 
    fc_layers = [nn.Linear(784, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_small.mat",nn1)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=200, network='odenet', save='../logs/cifarsmall', test_batch_size=1000, tol=0.001)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=200, network='odenet', save='../logs/cifarsmall', test_batch_size=1000, tol=0.001)
Sequential(
  (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(64, eps=64, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): AvgPool2d(kernel_size=2, stride=2, padding=0)
  (4): Conv2d(64, 128, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (5): BatchNorm2d(128, eps=128, momentum=0.1, affine=True, track_running_stats=True)
  (6): ReLU(inplace=True)
  (7): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (8): Conv2d(128, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (9): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (10): ReLU(inplace=True)
  (11): Conv2d(256, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (12): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (13): ReLU(inplace=True)
  (14): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (15): Conv2d(256, 512, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (16): BatchNorm2d(512, eps=512, momentum=0.1, affine=True, track_running_stats=True)
  (17): ReLU(inplace=True)
  (18): Conv2d(512, 512, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (19): BatchNorm2d(512, eps=512, momentum=0.1, affine=True, track_running_stats=True)
  (20): ReLU(inplace=True)
  (21): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (22): Flatten()
  (23): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=784, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=784, bias=True)
    )
  )
  (24): Linear(in_features=784, out_features=10, bias=True)
)
Sequential(
  (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(64, eps=64, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): AvgPool2d(kernel_size=2, stride=2, padding=0)
  (4): Conv2d(64, 128, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (5): BatchNorm2d(128, eps=128, momentum=0.1, affine=True, track_running_stats=True)
  (6): ReLU(inplace=True)
  (7): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (8): Conv2d(128, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (9): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (10): ReLU(inplace=True)
  (11): Conv2d(256, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (12): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (13): ReLU(inplace=True)
  (14): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (15): Conv2d(256, 512, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (16): BatchNorm2d(512, eps=512, momentum=0.1, affine=True, track_running_stats=True)
  (17): ReLU(inplace=True)
  (18): Conv2d(512, 512, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (19): BatchNorm2d(512, eps=512, momentum=0.1, affine=True, track_running_stats=True)
  (20): ReLU(inplace=True)
  (21): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (22): Flatten()
  (23): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=784, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=784, bias=True)
    )
  )
  (24): Linear(in_features=784, out_features=10, bias=True)
)
Number of parameters: 8036042
Number of parameters: 8036042
/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example_small.py
/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example_small.py
/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example_small.py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  4 09:04:31 2021

@author: manzand
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=200)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarsmall')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(512, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 64, 3, 1),
        norm(64),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(64, 128, 4, 2, 1),
        norm(128),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(128, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.Conv2d(256, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(256, 512, 4, 2, 1),
        norm(512),
        nn.ReLU(inplace = True),
        nn.Conv2d(512, 512, 4, 2, 1),
        norm(512),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        Flatten(),
    ]


    feature_layers = [ODEBlock(ODEfunc(784))] 
    fc_layers = [nn.Linear(784, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_small.mat",nn1)
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  4 09:04:31 2021

@author: manzand
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=200)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarsmall')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(512, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 64, 3, 1),
        norm(64),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(64, 128, 4, 2, 1),
        norm(128),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(128, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.Conv2d(256, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(256, 512, 4, 2, 1),
        norm(512),
        nn.ReLU(inplace = True),
        nn.Conv2d(512, 512, 4, 2, 1),
        norm(512),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        Flatten(),
    ]


    feature_layers = [ODEBlock(ODEfunc(784))] 
    fc_layers = [nn.Linear(784, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_small.mat",nn1)
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  4 09:04:31 2021

@author: manzand
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=200)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarsmall')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(512, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 64, 3, 1),
        norm(64),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(64, 128, 4, 2, 1),
        norm(128),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(128, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.Conv2d(256, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(256, 512, 4, 2, 1),
        norm(512),
        nn.ReLU(inplace = True),
        nn.Conv2d(512, 512, 4, 2, 1),
        norm(512),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        Flatten(),
    ]


    feature_layers = [ODEBlock(ODEfunc(784))] 
    fc_layers = [nn.Linear(784, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_small.mat",nn1)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=200, network='odenet', save='../logs/cifarsmall', test_batch_size=1000, tol=0.001)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=200, network='odenet', save='../logs/cifarsmall', test_batch_size=1000, tol=0.001)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=200, network='odenet', save='../logs/cifarsmall', test_batch_size=1000, tol=0.001)
Sequential(
  (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(64, eps=64, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (4): Conv2d(64, 128, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (5): BatchNorm2d(128, eps=128, momentum=0.1, affine=True, track_running_stats=True)
  (6): ReLU(inplace=True)
  (7): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (8): Conv2d(128, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (9): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (10): ReLU(inplace=True)
  (11): Conv2d(256, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (12): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (13): ReLU(inplace=True)
  (14): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (15): Conv2d(256, 512, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (16): BatchNorm2d(512, eps=512, momentum=0.1, affine=True, track_running_stats=True)
  (17): ReLU(inplace=True)
  (18): Conv2d(512, 512, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (19): BatchNorm2d(512, eps=512, momentum=0.1, affine=True, track_running_stats=True)
  (20): ReLU(inplace=True)
  (21): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (22): Flatten()
  (23): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=784, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=784, bias=True)
    )
  )
  (24): Linear(in_features=784, out_features=10, bias=True)
)
Sequential(
  (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(64, eps=64, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (4): Conv2d(64, 128, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (5): BatchNorm2d(128, eps=128, momentum=0.1, affine=True, track_running_stats=True)
  (6): ReLU(inplace=True)
  (7): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (8): Conv2d(128, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (9): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (10): ReLU(inplace=True)
  (11): Conv2d(256, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (12): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (13): ReLU(inplace=True)
  (14): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (15): Conv2d(256, 512, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (16): BatchNorm2d(512, eps=512, momentum=0.1, affine=True, track_running_stats=True)
  (17): ReLU(inplace=True)
  (18): Conv2d(512, 512, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (19): BatchNorm2d(512, eps=512, momentum=0.1, affine=True, track_running_stats=True)
  (20): ReLU(inplace=True)
  (21): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (22): Flatten()
  (23): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=784, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=784, bias=True)
    )
  )
  (24): Linear(in_features=784, out_features=10, bias=True)
)
Sequential(
  (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(64, eps=64, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (4): Conv2d(64, 128, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (5): BatchNorm2d(128, eps=128, momentum=0.1, affine=True, track_running_stats=True)
  (6): ReLU(inplace=True)
  (7): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (8): Conv2d(128, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (9): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (10): ReLU(inplace=True)
  (11): Conv2d(256, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (12): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (13): ReLU(inplace=True)
  (14): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (15): Conv2d(256, 512, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (16): BatchNorm2d(512, eps=512, momentum=0.1, affine=True, track_running_stats=True)
  (17): ReLU(inplace=True)
  (18): Conv2d(512, 512, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (19): BatchNorm2d(512, eps=512, momentum=0.1, affine=True, track_running_stats=True)
  (20): ReLU(inplace=True)
  (21): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (22): Flatten()
  (23): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=784, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=784, bias=True)
    )
  )
  (24): Linear(in_features=784, out_features=10, bias=True)
)
Number of parameters: 8036042
Number of parameters: 8036042
Number of parameters: 8036042
/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example_small.py
/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example_small.py
/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example_small.py
/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example_small.py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  4 09:04:31 2021

@author: manzand
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=200)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarsmall')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(512, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 64, 3, 1),
        norm(64),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(64, 128, 4, 2, 1),
        norm(128),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(128, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.Conv2d(256, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        # nn.Conv2d(256, 512, 4, 2, 1),
        # norm(512),
        # nn.ReLU(inplace = True),
        # nn.Conv2d(512, 512, 4, 2, 1),
        # norm(512),
        # nn.ReLU(inplace = True),
        # nn.AvgPool2d(2,1),
        Flatten(),
    ]


    feature_layers = [ODEBlock(ODEfunc(784))] 
    fc_layers = [nn.Linear(784, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_small.mat",nn1)
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  4 09:04:31 2021

@author: manzand
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=200)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarsmall')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(512, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 64, 3, 1),
        norm(64),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(64, 128, 4, 2, 1),
        norm(128),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(128, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.Conv2d(256, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        # nn.Conv2d(256, 512, 4, 2, 1),
        # norm(512),
        # nn.ReLU(inplace = True),
        # nn.Conv2d(512, 512, 4, 2, 1),
        # norm(512),
        # nn.ReLU(inplace = True),
        # nn.AvgPool2d(2,1),
        Flatten(),
    ]


    feature_layers = [ODEBlock(ODEfunc(784))] 
    fc_layers = [nn.Linear(784, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_small.mat",nn1)
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  4 09:04:31 2021

@author: manzand
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=200)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarsmall')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(512, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 64, 3, 1),
        norm(64),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(64, 128, 4, 2, 1),
        norm(128),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(128, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.Conv2d(256, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        # nn.Conv2d(256, 512, 4, 2, 1),
        # norm(512),
        # nn.ReLU(inplace = True),
        # nn.Conv2d(512, 512, 4, 2, 1),
        # norm(512),
        # nn.ReLU(inplace = True),
        # nn.AvgPool2d(2,1),
        Flatten(),
    ]


    feature_layers = [ODEBlock(ODEfunc(784))] 
    fc_layers = [nn.Linear(784, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_small.mat",nn1)
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  4 09:04:31 2021

@author: manzand
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=200)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarsmall')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(512, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 64, 3, 1),
        norm(64),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(64, 128, 4, 2, 1),
        norm(128),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(128, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.Conv2d(256, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        # nn.Conv2d(256, 512, 4, 2, 1),
        # norm(512),
        # nn.ReLU(inplace = True),
        # nn.Conv2d(512, 512, 4, 2, 1),
        # norm(512),
        # nn.ReLU(inplace = True),
        # nn.AvgPool2d(2,1),
        Flatten(),
    ]


    feature_layers = [ODEBlock(ODEfunc(784))] 
    fc_layers = [nn.Linear(784, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_small.mat",nn1)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=200, network='odenet', save='../logs/cifarsmall', test_batch_size=1000, tol=0.001)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=200, network='odenet', save='../logs/cifarsmall', test_batch_size=1000, tol=0.001)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=200, network='odenet', save='../logs/cifarsmall', test_batch_size=1000, tol=0.001)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=200, network='odenet', save='../logs/cifarsmall', test_batch_size=1000, tol=0.001)
Sequential(
  (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(64, eps=64, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (4): Conv2d(64, 128, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (5): BatchNorm2d(128, eps=128, momentum=0.1, affine=True, track_running_stats=True)
  (6): ReLU(inplace=True)
  (7): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (8): Conv2d(128, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (9): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (10): ReLU(inplace=True)
  (11): Conv2d(256, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (12): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (13): ReLU(inplace=True)
  (14): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (15): Flatten()
  (16): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=784, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=784, bias=True)
    )
  )
  (17): Linear(in_features=784, out_features=10, bias=True)
)
Sequential(
  (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(64, eps=64, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (4): Conv2d(64, 128, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (5): BatchNorm2d(128, eps=128, momentum=0.1, affine=True, track_running_stats=True)
  (6): ReLU(inplace=True)
  (7): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (8): Conv2d(128, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (9): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (10): ReLU(inplace=True)
  (11): Conv2d(256, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (12): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (13): ReLU(inplace=True)
  (14): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (15): Flatten()
  (16): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=784, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=784, bias=True)
    )
  )
  (17): Linear(in_features=784, out_features=10, bias=True)
)
Sequential(
  (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(64, eps=64, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (4): Conv2d(64, 128, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (5): BatchNorm2d(128, eps=128, momentum=0.1, affine=True, track_running_stats=True)
  (6): ReLU(inplace=True)
  (7): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (8): Conv2d(128, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (9): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (10): ReLU(inplace=True)
  (11): Conv2d(256, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (12): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (13): ReLU(inplace=True)
  (14): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (15): Flatten()
  (16): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=784, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=784, bias=True)
    )
  )
  (17): Linear(in_features=784, out_features=10, bias=True)
)
Sequential(
  (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(64, eps=64, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (4): Conv2d(64, 128, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (5): BatchNorm2d(128, eps=128, momentum=0.1, affine=True, track_running_stats=True)
  (6): ReLU(inplace=True)
  (7): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (8): Conv2d(128, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (9): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (10): ReLU(inplace=True)
  (11): Conv2d(256, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (12): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (13): ReLU(inplace=True)
  (14): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (15): Flatten()
  (16): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=784, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=784, bias=True)
    )
  )
  (17): Linear(in_features=784, out_features=10, bias=True)
)
Number of parameters: 1741514
Number of parameters: 1741514
Number of parameters: 1741514
Number of parameters: 1741514
/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example_small.py
/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example_small.py
/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example_small.py
/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example_small.py
/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example_small.py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  4 09:04:31 2021

@author: manzand
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=200)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarsmall')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(512, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 64, 3, 1),
        norm(64),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(64, 128, 4, 2, 1),
        norm(128),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(128, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.Conv2d(256, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(256, 512, 4, 2, 1),
        norm(512),
        nn.ReLU(inplace = True),
        # nn.Conv2d(512, 512, 4, 2, 1),
        # norm(512),
        # nn.ReLU(inplace = True),
        # nn.AvgPool2d(2,1),
        Flatten(),
    ]


    feature_layers = [ODEBlock(ODEfunc(784))] 
    fc_layers = [nn.Linear(784, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_small.mat",nn1)
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  4 09:04:31 2021

@author: manzand
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=200)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarsmall')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(512, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 64, 3, 1),
        norm(64),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(64, 128, 4, 2, 1),
        norm(128),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(128, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.Conv2d(256, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(256, 512, 4, 2, 1),
        norm(512),
        nn.ReLU(inplace = True),
        # nn.Conv2d(512, 512, 4, 2, 1),
        # norm(512),
        # nn.ReLU(inplace = True),
        # nn.AvgPool2d(2,1),
        Flatten(),
    ]


    feature_layers = [ODEBlock(ODEfunc(784))] 
    fc_layers = [nn.Linear(784, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_small.mat",nn1)
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  4 09:04:31 2021

@author: manzand
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=200)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarsmall')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(512, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 64, 3, 1),
        norm(64),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(64, 128, 4, 2, 1),
        norm(128),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(128, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.Conv2d(256, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(256, 512, 4, 2, 1),
        norm(512),
        nn.ReLU(inplace = True),
        # nn.Conv2d(512, 512, 4, 2, 1),
        # norm(512),
        # nn.ReLU(inplace = True),
        # nn.AvgPool2d(2,1),
        Flatten(),
    ]


    feature_layers = [ODEBlock(ODEfunc(784))] 
    fc_layers = [nn.Linear(784, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_small.mat",nn1)
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  4 09:04:31 2021

@author: manzand
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=200)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarsmall')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(512, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 64, 3, 1),
        norm(64),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(64, 128, 4, 2, 1),
        norm(128),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(128, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.Conv2d(256, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(256, 512, 4, 2, 1),
        norm(512),
        nn.ReLU(inplace = True),
        # nn.Conv2d(512, 512, 4, 2, 1),
        # norm(512),
        # nn.ReLU(inplace = True),
        # nn.AvgPool2d(2,1),
        Flatten(),
    ]


    feature_layers = [ODEBlock(ODEfunc(784))] 
    fc_layers = [nn.Linear(784, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_small.mat",nn1)
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  4 09:04:31 2021

@author: manzand
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=200)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarsmall')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(512, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 64, 3, 1),
        norm(64),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(64, 128, 4, 2, 1),
        norm(128),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(128, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.Conv2d(256, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(256, 512, 4, 2, 1),
        norm(512),
        nn.ReLU(inplace = True),
        # nn.Conv2d(512, 512, 4, 2, 1),
        # norm(512),
        # nn.ReLU(inplace = True),
        # nn.AvgPool2d(2,1),
        Flatten(),
    ]


    feature_layers = [ODEBlock(ODEfunc(784))] 
    fc_layers = [nn.Linear(784, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_small.mat",nn1)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=200, network='odenet', save='../logs/cifarsmall', test_batch_size=1000, tol=0.001)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=200, network='odenet', save='../logs/cifarsmall', test_batch_size=1000, tol=0.001)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=200, network='odenet', save='../logs/cifarsmall', test_batch_size=1000, tol=0.001)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=200, network='odenet', save='../logs/cifarsmall', test_batch_size=1000, tol=0.001)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=200, network='odenet', save='../logs/cifarsmall', test_batch_size=1000, tol=0.001)
Sequential(
  (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(64, eps=64, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (4): Conv2d(64, 128, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (5): BatchNorm2d(128, eps=128, momentum=0.1, affine=True, track_running_stats=True)
  (6): ReLU(inplace=True)
  (7): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (8): Conv2d(128, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (9): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (10): ReLU(inplace=True)
  (11): Conv2d(256, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (12): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (13): ReLU(inplace=True)
  (14): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (15): Conv2d(256, 512, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (16): BatchNorm2d(512, eps=512, momentum=0.1, affine=True, track_running_stats=True)
  (17): ReLU(inplace=True)
  (18): Flatten()
  (19): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=784, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=784, bias=True)
    )
  )
  (20): Linear(in_features=784, out_features=10, bias=True)
)
Sequential(
  (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(64, eps=64, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (4): Conv2d(64, 128, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (5): BatchNorm2d(128, eps=128, momentum=0.1, affine=True, track_running_stats=True)
  (6): ReLU(inplace=True)
  (7): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (8): Conv2d(128, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (9): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (10): ReLU(inplace=True)
  (11): Conv2d(256, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (12): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (13): ReLU(inplace=True)
  (14): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (15): Conv2d(256, 512, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (16): BatchNorm2d(512, eps=512, momentum=0.1, affine=True, track_running_stats=True)
  (17): ReLU(inplace=True)
  (18): Flatten()
  (19): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=784, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=784, bias=True)
    )
  )
  (20): Linear(in_features=784, out_features=10, bias=True)
)
Sequential(
  (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(64, eps=64, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (4): Conv2d(64, 128, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (5): BatchNorm2d(128, eps=128, momentum=0.1, affine=True, track_running_stats=True)
  (6): ReLU(inplace=True)
  (7): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (8): Conv2d(128, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (9): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (10): ReLU(inplace=True)
  (11): Conv2d(256, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (12): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (13): ReLU(inplace=True)
  (14): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (15): Conv2d(256, 512, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (16): BatchNorm2d(512, eps=512, momentum=0.1, affine=True, track_running_stats=True)
  (17): ReLU(inplace=True)
  (18): Flatten()
  (19): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=784, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=784, bias=True)
    )
  )
  (20): Linear(in_features=784, out_features=10, bias=True)
)
Sequential(
  (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(64, eps=64, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (4): Conv2d(64, 128, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (5): BatchNorm2d(128, eps=128, momentum=0.1, affine=True, track_running_stats=True)
  (6): ReLU(inplace=True)
  (7): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (8): Conv2d(128, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (9): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (10): ReLU(inplace=True)
  (11): Conv2d(256, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (12): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (13): ReLU(inplace=True)
  (14): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (15): Conv2d(256, 512, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (16): BatchNorm2d(512, eps=512, momentum=0.1, affine=True, track_running_stats=True)
  (17): ReLU(inplace=True)
  (18): Flatten()
  (19): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=784, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=784, bias=True)
    )
  )
  (20): Linear(in_features=784, out_features=10, bias=True)
)
Sequential(
  (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(64, eps=64, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (4): Conv2d(64, 128, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (5): BatchNorm2d(128, eps=128, momentum=0.1, affine=True, track_running_stats=True)
  (6): ReLU(inplace=True)
  (7): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (8): Conv2d(128, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (9): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (10): ReLU(inplace=True)
  (11): Conv2d(256, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (12): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (13): ReLU(inplace=True)
  (14): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (15): Conv2d(256, 512, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (16): BatchNorm2d(512, eps=512, momentum=0.1, affine=True, track_running_stats=True)
  (17): ReLU(inplace=True)
  (18): Flatten()
  (19): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=784, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=784, bias=True)
    )
  )
  (20): Linear(in_features=784, out_features=10, bias=True)
)
Number of parameters: 3840202
Number of parameters: 3840202
Number of parameters: 3840202
Number of parameters: 3840202
Number of parameters: 3840202
/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example_small.py
/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example_small.py
/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example_small.py
/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example_small.py
/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example_small.py
/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example_small.py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  4 09:04:31 2021

@author: manzand
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=200)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarsmall')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(512, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 64, 3, 1),
        norm(64),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(64, 128, 4, 2, 1),
        norm(128),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(128, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.Conv2d(256, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(256, 512, 4, 2, 1),
        norm(512),
        nn.ReLU(inplace = True),
        # nn.Conv2d(512, 512, 4, 2, 1),
        # norm(512),
        # nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        Flatten(),
    ]


    feature_layers = [ODEBlock(ODEfunc(784))] 
    fc_layers = [nn.Linear(784, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_small.mat",nn1)
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  4 09:04:31 2021

@author: manzand
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=200)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarsmall')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(512, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 64, 3, 1),
        norm(64),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(64, 128, 4, 2, 1),
        norm(128),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(128, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.Conv2d(256, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(256, 512, 4, 2, 1),
        norm(512),
        nn.ReLU(inplace = True),
        # nn.Conv2d(512, 512, 4, 2, 1),
        # norm(512),
        # nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        Flatten(),
    ]


    feature_layers = [ODEBlock(ODEfunc(784))] 
    fc_layers = [nn.Linear(784, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_small.mat",nn1)
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  4 09:04:31 2021

@author: manzand
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=200)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarsmall')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(512, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 64, 3, 1),
        norm(64),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(64, 128, 4, 2, 1),
        norm(128),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(128, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.Conv2d(256, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(256, 512, 4, 2, 1),
        norm(512),
        nn.ReLU(inplace = True),
        # nn.Conv2d(512, 512, 4, 2, 1),
        # norm(512),
        # nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        Flatten(),
    ]


    feature_layers = [ODEBlock(ODEfunc(784))] 
    fc_layers = [nn.Linear(784, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_small.mat",nn1)
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  4 09:04:31 2021

@author: manzand
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=200)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarsmall')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(512, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 64, 3, 1),
        norm(64),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(64, 128, 4, 2, 1),
        norm(128),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(128, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.Conv2d(256, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(256, 512, 4, 2, 1),
        norm(512),
        nn.ReLU(inplace = True),
        # nn.Conv2d(512, 512, 4, 2, 1),
        # norm(512),
        # nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        Flatten(),
    ]


    feature_layers = [ODEBlock(ODEfunc(784))] 
    fc_layers = [nn.Linear(784, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_small.mat",nn1)
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  4 09:04:31 2021

@author: manzand
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=200)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarsmall')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(512, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 64, 3, 1),
        norm(64),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(64, 128, 4, 2, 1),
        norm(128),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(128, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.Conv2d(256, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(256, 512, 4, 2, 1),
        norm(512),
        nn.ReLU(inplace = True),
        # nn.Conv2d(512, 512, 4, 2, 1),
        # norm(512),
        # nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        Flatten(),
    ]


    feature_layers = [ODEBlock(ODEfunc(784))] 
    fc_layers = [nn.Linear(784, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_small.mat",nn1)
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  4 09:04:31 2021

@author: manzand
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=200)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarsmall')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(512, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 64, 3, 1),
        norm(64),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(64, 128, 4, 2, 1),
        norm(128),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(128, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.Conv2d(256, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(256, 512, 4, 2, 1),
        norm(512),
        nn.ReLU(inplace = True),
        # nn.Conv2d(512, 512, 4, 2, 1),
        # norm(512),
        # nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        Flatten(),
    ]


    feature_layers = [ODEBlock(ODEfunc(784))] 
    fc_layers = [nn.Linear(784, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_small.mat",nn1)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=200, network='odenet', save='../logs/cifarsmall', test_batch_size=1000, tol=0.001)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=200, network='odenet', save='../logs/cifarsmall', test_batch_size=1000, tol=0.001)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=200, network='odenet', save='../logs/cifarsmall', test_batch_size=1000, tol=0.001)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=200, network='odenet', save='../logs/cifarsmall', test_batch_size=1000, tol=0.001)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=200, network='odenet', save='../logs/cifarsmall', test_batch_size=1000, tol=0.001)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=200, network='odenet', save='../logs/cifarsmall', test_batch_size=1000, tol=0.001)
Sequential(
  (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(64, eps=64, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (4): Conv2d(64, 128, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (5): BatchNorm2d(128, eps=128, momentum=0.1, affine=True, track_running_stats=True)
  (6): ReLU(inplace=True)
  (7): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (8): Conv2d(128, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (9): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (10): ReLU(inplace=True)
  (11): Conv2d(256, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (12): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (13): ReLU(inplace=True)
  (14): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (15): Conv2d(256, 512, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (16): BatchNorm2d(512, eps=512, momentum=0.1, affine=True, track_running_stats=True)
  (17): ReLU(inplace=True)
  (18): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (19): Flatten()
  (20): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=784, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=784, bias=True)
    )
  )
  (21): Linear(in_features=784, out_features=10, bias=True)
)
Sequential(
  (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(64, eps=64, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (4): Conv2d(64, 128, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (5): BatchNorm2d(128, eps=128, momentum=0.1, affine=True, track_running_stats=True)
  (6): ReLU(inplace=True)
  (7): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (8): Conv2d(128, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (9): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (10): ReLU(inplace=True)
  (11): Conv2d(256, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (12): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (13): ReLU(inplace=True)
  (14): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (15): Conv2d(256, 512, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (16): BatchNorm2d(512, eps=512, momentum=0.1, affine=True, track_running_stats=True)
  (17): ReLU(inplace=True)
  (18): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (19): Flatten()
  (20): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=784, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=784, bias=True)
    )
  )
  (21): Linear(in_features=784, out_features=10, bias=True)
)
Sequential(
  (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(64, eps=64, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (4): Conv2d(64, 128, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (5): BatchNorm2d(128, eps=128, momentum=0.1, affine=True, track_running_stats=True)
  (6): ReLU(inplace=True)
  (7): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (8): Conv2d(128, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (9): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (10): ReLU(inplace=True)
  (11): Conv2d(256, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (12): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (13): ReLU(inplace=True)
  (14): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (15): Conv2d(256, 512, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (16): BatchNorm2d(512, eps=512, momentum=0.1, affine=True, track_running_stats=True)
  (17): ReLU(inplace=True)
  (18): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (19): Flatten()
  (20): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=784, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=784, bias=True)
    )
  )
  (21): Linear(in_features=784, out_features=10, bias=True)
)
Sequential(
  (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(64, eps=64, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (4): Conv2d(64, 128, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (5): BatchNorm2d(128, eps=128, momentum=0.1, affine=True, track_running_stats=True)
  (6): ReLU(inplace=True)
  (7): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (8): Conv2d(128, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (9): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (10): ReLU(inplace=True)
  (11): Conv2d(256, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (12): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (13): ReLU(inplace=True)
  (14): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (15): Conv2d(256, 512, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (16): BatchNorm2d(512, eps=512, momentum=0.1, affine=True, track_running_stats=True)
  (17): ReLU(inplace=True)
  (18): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (19): Flatten()
  (20): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=784, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=784, bias=True)
    )
  )
  (21): Linear(in_features=784, out_features=10, bias=True)
)
Sequential(
  (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(64, eps=64, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (4): Conv2d(64, 128, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (5): BatchNorm2d(128, eps=128, momentum=0.1, affine=True, track_running_stats=True)
  (6): ReLU(inplace=True)
  (7): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (8): Conv2d(128, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (9): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (10): ReLU(inplace=True)
  (11): Conv2d(256, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (12): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (13): ReLU(inplace=True)
  (14): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (15): Conv2d(256, 512, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (16): BatchNorm2d(512, eps=512, momentum=0.1, affine=True, track_running_stats=True)
  (17): ReLU(inplace=True)
  (18): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (19): Flatten()
  (20): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=784, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=784, bias=True)
    )
  )
  (21): Linear(in_features=784, out_features=10, bias=True)
)
Sequential(
  (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(64, eps=64, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (4): Conv2d(64, 128, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (5): BatchNorm2d(128, eps=128, momentum=0.1, affine=True, track_running_stats=True)
  (6): ReLU(inplace=True)
  (7): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (8): Conv2d(128, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (9): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (10): ReLU(inplace=True)
  (11): Conv2d(256, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (12): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (13): ReLU(inplace=True)
  (14): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (15): Conv2d(256, 512, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (16): BatchNorm2d(512, eps=512, momentum=0.1, affine=True, track_running_stats=True)
  (17): ReLU(inplace=True)
  (18): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (19): Flatten()
  (20): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=784, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=784, bias=True)
    )
  )
  (21): Linear(in_features=784, out_features=10, bias=True)
)
Number of parameters: 3840202
Number of parameters: 3840202
Number of parameters: 3840202
Number of parameters: 3840202
Number of parameters: 3840202
Number of parameters: 3840202
/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example_small.py
/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example_small.py
/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example_small.py
/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example_small.py
/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example_small.py
/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example_small.py
/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example_small.py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  4 09:04:31 2021

@author: manzand
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=200)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarsmall')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(512, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 64, 3, 1),
        norm(64),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(64, 128, 4, 2, 1),
        norm(128),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(128, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.Conv2d(256, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(256, 512, 4, 2, 1),
        norm(512),
        nn.ReLU(inplace = True),
        # nn.Conv2d(512, 512, 4, 2, 1),
        # norm(512),
        # nn.ReLU(inplace = True),
        nn.AvgPool2d(2,2),
        Flatten(),
    ]


    feature_layers = [ODEBlock(ODEfunc(784))] 
    fc_layers = [nn.Linear(784, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_small.mat",nn1)
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  4 09:04:31 2021

@author: manzand
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=200)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarsmall')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(512, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 64, 3, 1),
        norm(64),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(64, 128, 4, 2, 1),
        norm(128),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(128, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.Conv2d(256, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(256, 512, 4, 2, 1),
        norm(512),
        nn.ReLU(inplace = True),
        # nn.Conv2d(512, 512, 4, 2, 1),
        # norm(512),
        # nn.ReLU(inplace = True),
        nn.AvgPool2d(2,2),
        Flatten(),
    ]


    feature_layers = [ODEBlock(ODEfunc(784))] 
    fc_layers = [nn.Linear(784, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_small.mat",nn1)
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  4 09:04:31 2021

@author: manzand
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=200)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarsmall')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(512, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 64, 3, 1),
        norm(64),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(64, 128, 4, 2, 1),
        norm(128),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(128, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.Conv2d(256, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(256, 512, 4, 2, 1),
        norm(512),
        nn.ReLU(inplace = True),
        # nn.Conv2d(512, 512, 4, 2, 1),
        # norm(512),
        # nn.ReLU(inplace = True),
        nn.AvgPool2d(2,2),
        Flatten(),
    ]


    feature_layers = [ODEBlock(ODEfunc(784))] 
    fc_layers = [nn.Linear(784, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_small.mat",nn1)
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  4 09:04:31 2021

@author: manzand
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=200)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarsmall')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(512, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 64, 3, 1),
        norm(64),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(64, 128, 4, 2, 1),
        norm(128),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(128, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.Conv2d(256, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(256, 512, 4, 2, 1),
        norm(512),
        nn.ReLU(inplace = True),
        # nn.Conv2d(512, 512, 4, 2, 1),
        # norm(512),
        # nn.ReLU(inplace = True),
        nn.AvgPool2d(2,2),
        Flatten(),
    ]


    feature_layers = [ODEBlock(ODEfunc(784))] 
    fc_layers = [nn.Linear(784, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_small.mat",nn1)
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  4 09:04:31 2021

@author: manzand
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=200)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarsmall')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(512, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 64, 3, 1),
        norm(64),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(64, 128, 4, 2, 1),
        norm(128),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(128, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.Conv2d(256, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(256, 512, 4, 2, 1),
        norm(512),
        nn.ReLU(inplace = True),
        # nn.Conv2d(512, 512, 4, 2, 1),
        # norm(512),
        # nn.ReLU(inplace = True),
        nn.AvgPool2d(2,2),
        Flatten(),
    ]


    feature_layers = [ODEBlock(ODEfunc(784))] 
    fc_layers = [nn.Linear(784, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_small.mat",nn1)
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  4 09:04:31 2021

@author: manzand
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=200)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarsmall')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(512, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 64, 3, 1),
        norm(64),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(64, 128, 4, 2, 1),
        norm(128),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(128, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.Conv2d(256, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(256, 512, 4, 2, 1),
        norm(512),
        nn.ReLU(inplace = True),
        # nn.Conv2d(512, 512, 4, 2, 1),
        # norm(512),
        # nn.ReLU(inplace = True),
        nn.AvgPool2d(2,2),
        Flatten(),
    ]


    feature_layers = [ODEBlock(ODEfunc(784))] 
    fc_layers = [nn.Linear(784, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_small.mat",nn1)
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  4 09:04:31 2021

@author: manzand
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=200)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarsmall')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(512, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 64, 3, 1),
        norm(64),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(64, 128, 4, 2, 1),
        norm(128),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(128, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.Conv2d(256, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(256, 512, 4, 2, 1),
        norm(512),
        nn.ReLU(inplace = True),
        # nn.Conv2d(512, 512, 4, 2, 1),
        # norm(512),
        # nn.ReLU(inplace = True),
        nn.AvgPool2d(2,2),
        Flatten(),
    ]


    feature_layers = [ODEBlock(ODEfunc(784))] 
    fc_layers = [nn.Linear(784, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_small.mat",nn1)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=200, network='odenet', save='../logs/cifarsmall', test_batch_size=1000, tol=0.001)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=200, network='odenet', save='../logs/cifarsmall', test_batch_size=1000, tol=0.001)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=200, network='odenet', save='../logs/cifarsmall', test_batch_size=1000, tol=0.001)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=200, network='odenet', save='../logs/cifarsmall', test_batch_size=1000, tol=0.001)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=200, network='odenet', save='../logs/cifarsmall', test_batch_size=1000, tol=0.001)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=200, network='odenet', save='../logs/cifarsmall', test_batch_size=1000, tol=0.001)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=200, network='odenet', save='../logs/cifarsmall', test_batch_size=1000, tol=0.001)
Sequential(
  (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(64, eps=64, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (4): Conv2d(64, 128, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (5): BatchNorm2d(128, eps=128, momentum=0.1, affine=True, track_running_stats=True)
  (6): ReLU(inplace=True)
  (7): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (8): Conv2d(128, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (9): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (10): ReLU(inplace=True)
  (11): Conv2d(256, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (12): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (13): ReLU(inplace=True)
  (14): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (15): Conv2d(256, 512, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (16): BatchNorm2d(512, eps=512, momentum=0.1, affine=True, track_running_stats=True)
  (17): ReLU(inplace=True)
  (18): AvgPool2d(kernel_size=2, stride=2, padding=0)
  (19): Flatten()
  (20): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=784, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=784, bias=True)
    )
  )
  (21): Linear(in_features=784, out_features=10, bias=True)
)
Sequential(
  (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(64, eps=64, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (4): Conv2d(64, 128, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (5): BatchNorm2d(128, eps=128, momentum=0.1, affine=True, track_running_stats=True)
  (6): ReLU(inplace=True)
  (7): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (8): Conv2d(128, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (9): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (10): ReLU(inplace=True)
  (11): Conv2d(256, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (12): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (13): ReLU(inplace=True)
  (14): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (15): Conv2d(256, 512, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (16): BatchNorm2d(512, eps=512, momentum=0.1, affine=True, track_running_stats=True)
  (17): ReLU(inplace=True)
  (18): AvgPool2d(kernel_size=2, stride=2, padding=0)
  (19): Flatten()
  (20): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=784, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=784, bias=True)
    )
  )
  (21): Linear(in_features=784, out_features=10, bias=True)
)
Sequential(
  (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(64, eps=64, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (4): Conv2d(64, 128, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (5): BatchNorm2d(128, eps=128, momentum=0.1, affine=True, track_running_stats=True)
  (6): ReLU(inplace=True)
  (7): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (8): Conv2d(128, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (9): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (10): ReLU(inplace=True)
  (11): Conv2d(256, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (12): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (13): ReLU(inplace=True)
  (14): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (15): Conv2d(256, 512, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (16): BatchNorm2d(512, eps=512, momentum=0.1, affine=True, track_running_stats=True)
  (17): ReLU(inplace=True)
  (18): AvgPool2d(kernel_size=2, stride=2, padding=0)
  (19): Flatten()
  (20): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=784, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=784, bias=True)
    )
  )
  (21): Linear(in_features=784, out_features=10, bias=True)
)
Sequential(
  (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(64, eps=64, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (4): Conv2d(64, 128, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (5): BatchNorm2d(128, eps=128, momentum=0.1, affine=True, track_running_stats=True)
  (6): ReLU(inplace=True)
  (7): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (8): Conv2d(128, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (9): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (10): ReLU(inplace=True)
  (11): Conv2d(256, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (12): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (13): ReLU(inplace=True)
  (14): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (15): Conv2d(256, 512, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (16): BatchNorm2d(512, eps=512, momentum=0.1, affine=True, track_running_stats=True)
  (17): ReLU(inplace=True)
  (18): AvgPool2d(kernel_size=2, stride=2, padding=0)
  (19): Flatten()
  (20): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=784, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=784, bias=True)
    )
  )
  (21): Linear(in_features=784, out_features=10, bias=True)
)
Sequential(
  (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(64, eps=64, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (4): Conv2d(64, 128, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (5): BatchNorm2d(128, eps=128, momentum=0.1, affine=True, track_running_stats=True)
  (6): ReLU(inplace=True)
  (7): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (8): Conv2d(128, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (9): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (10): ReLU(inplace=True)
  (11): Conv2d(256, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (12): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (13): ReLU(inplace=True)
  (14): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (15): Conv2d(256, 512, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (16): BatchNorm2d(512, eps=512, momentum=0.1, affine=True, track_running_stats=True)
  (17): ReLU(inplace=True)
  (18): AvgPool2d(kernel_size=2, stride=2, padding=0)
  (19): Flatten()
  (20): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=784, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=784, bias=True)
    )
  )
  (21): Linear(in_features=784, out_features=10, bias=True)
)
Sequential(
  (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(64, eps=64, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (4): Conv2d(64, 128, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (5): BatchNorm2d(128, eps=128, momentum=0.1, affine=True, track_running_stats=True)
  (6): ReLU(inplace=True)
  (7): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (8): Conv2d(128, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (9): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (10): ReLU(inplace=True)
  (11): Conv2d(256, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (12): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (13): ReLU(inplace=True)
  (14): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (15): Conv2d(256, 512, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (16): BatchNorm2d(512, eps=512, momentum=0.1, affine=True, track_running_stats=True)
  (17): ReLU(inplace=True)
  (18): AvgPool2d(kernel_size=2, stride=2, padding=0)
  (19): Flatten()
  (20): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=784, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=784, bias=True)
    )
  )
  (21): Linear(in_features=784, out_features=10, bias=True)
)
Sequential(
  (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(64, eps=64, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (4): Conv2d(64, 128, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (5): BatchNorm2d(128, eps=128, momentum=0.1, affine=True, track_running_stats=True)
  (6): ReLU(inplace=True)
  (7): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (8): Conv2d(128, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (9): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (10): ReLU(inplace=True)
  (11): Conv2d(256, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (12): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (13): ReLU(inplace=True)
  (14): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (15): Conv2d(256, 512, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (16): BatchNorm2d(512, eps=512, momentum=0.1, affine=True, track_running_stats=True)
  (17): ReLU(inplace=True)
  (18): AvgPool2d(kernel_size=2, stride=2, padding=0)
  (19): Flatten()
  (20): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=784, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=784, bias=True)
    )
  )
  (21): Linear(in_features=784, out_features=10, bias=True)
)
Number of parameters: 3840202
Number of parameters: 3840202
Number of parameters: 3840202
Number of parameters: 3840202
Number of parameters: 3840202
Number of parameters: 3840202
Number of parameters: 3840202
/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example_small.py
/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example_small.py
/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example_small.py
/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example_small.py
/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example_small.py
/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example_small.py
/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example_small.py
/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example_small.py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  4 09:04:31 2021

@author: manzand
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=200)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarsmall')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(512, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 64, 3, 1),
        norm(64),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(64, 128, 4, 2, 1),
        norm(128),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(128, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.Conv2d(256, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(256, 512, 4, 2, 1),
        norm(512),
        nn.ReLU(inplace = True),
        # nn.Conv2d(512, 512, 4, 2, 1),
        # norm(512),
        # nn.ReLU(inplace = True),
        # nn.AvgPool2d(2,2),
        Flatten(),
    ]


    feature_layers = [ODEBlock(ODEfunc(784))] 
    fc_layers = [nn.Linear(784, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_small.mat",nn1)
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  4 09:04:31 2021

@author: manzand
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=200)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarsmall')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(512, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 64, 3, 1),
        norm(64),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(64, 128, 4, 2, 1),
        norm(128),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(128, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.Conv2d(256, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(256, 512, 4, 2, 1),
        norm(512),
        nn.ReLU(inplace = True),
        # nn.Conv2d(512, 512, 4, 2, 1),
        # norm(512),
        # nn.ReLU(inplace = True),
        # nn.AvgPool2d(2,2),
        Flatten(),
    ]


    feature_layers = [ODEBlock(ODEfunc(784))] 
    fc_layers = [nn.Linear(784, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_small.mat",nn1)
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  4 09:04:31 2021

@author: manzand
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=200)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarsmall')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(512, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 64, 3, 1),
        norm(64),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(64, 128, 4, 2, 1),
        norm(128),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(128, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.Conv2d(256, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(256, 512, 4, 2, 1),
        norm(512),
        nn.ReLU(inplace = True),
        # nn.Conv2d(512, 512, 4, 2, 1),
        # norm(512),
        # nn.ReLU(inplace = True),
        # nn.AvgPool2d(2,2),
        Flatten(),
    ]


    feature_layers = [ODEBlock(ODEfunc(784))] 
    fc_layers = [nn.Linear(784, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_small.mat",nn1)
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  4 09:04:31 2021

@author: manzand
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=200)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarsmall')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(512, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 64, 3, 1),
        norm(64),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(64, 128, 4, 2, 1),
        norm(128),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(128, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.Conv2d(256, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(256, 512, 4, 2, 1),
        norm(512),
        nn.ReLU(inplace = True),
        # nn.Conv2d(512, 512, 4, 2, 1),
        # norm(512),
        # nn.ReLU(inplace = True),
        # nn.AvgPool2d(2,2),
        Flatten(),
    ]


    feature_layers = [ODEBlock(ODEfunc(784))] 
    fc_layers = [nn.Linear(784, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_small.mat",nn1)
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  4 09:04:31 2021

@author: manzand
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=200)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarsmall')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(512, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 64, 3, 1),
        norm(64),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(64, 128, 4, 2, 1),
        norm(128),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(128, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.Conv2d(256, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(256, 512, 4, 2, 1),
        norm(512),
        nn.ReLU(inplace = True),
        # nn.Conv2d(512, 512, 4, 2, 1),
        # norm(512),
        # nn.ReLU(inplace = True),
        # nn.AvgPool2d(2,2),
        Flatten(),
    ]


    feature_layers = [ODEBlock(ODEfunc(784))] 
    fc_layers = [nn.Linear(784, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_small.mat",nn1)
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  4 09:04:31 2021

@author: manzand
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=200)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarsmall')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(512, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 64, 3, 1),
        norm(64),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(64, 128, 4, 2, 1),
        norm(128),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(128, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.Conv2d(256, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(256, 512, 4, 2, 1),
        norm(512),
        nn.ReLU(inplace = True),
        # nn.Conv2d(512, 512, 4, 2, 1),
        # norm(512),
        # nn.ReLU(inplace = True),
        # nn.AvgPool2d(2,2),
        Flatten(),
    ]


    feature_layers = [ODEBlock(ODEfunc(784))] 
    fc_layers = [nn.Linear(784, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_small.mat",nn1)
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  4 09:04:31 2021

@author: manzand
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=200)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarsmall')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(512, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 64, 3, 1),
        norm(64),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(64, 128, 4, 2, 1),
        norm(128),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(128, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.Conv2d(256, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(256, 512, 4, 2, 1),
        norm(512),
        nn.ReLU(inplace = True),
        # nn.Conv2d(512, 512, 4, 2, 1),
        # norm(512),
        # nn.ReLU(inplace = True),
        # nn.AvgPool2d(2,2),
        Flatten(),
    ]


    feature_layers = [ODEBlock(ODEfunc(784))] 
    fc_layers = [nn.Linear(784, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_small.mat",nn1)
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  4 09:04:31 2021

@author: manzand
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=200)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarsmall')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(512, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 64, 3, 1),
        norm(64),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(64, 128, 4, 2, 1),
        norm(128),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(128, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.Conv2d(256, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(256, 512, 4, 2, 1),
        norm(512),
        nn.ReLU(inplace = True),
        # nn.Conv2d(512, 512, 4, 2, 1),
        # norm(512),
        # nn.ReLU(inplace = True),
        # nn.AvgPool2d(2,2),
        Flatten(),
    ]


    feature_layers = [ODEBlock(ODEfunc(784))] 
    fc_layers = [nn.Linear(784, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_small.mat",nn1)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=200, network='odenet', save='../logs/cifarsmall', test_batch_size=1000, tol=0.001)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=200, network='odenet', save='../logs/cifarsmall', test_batch_size=1000, tol=0.001)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=200, network='odenet', save='../logs/cifarsmall', test_batch_size=1000, tol=0.001)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=200, network='odenet', save='../logs/cifarsmall', test_batch_size=1000, tol=0.001)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=200, network='odenet', save='../logs/cifarsmall', test_batch_size=1000, tol=0.001)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=200, network='odenet', save='../logs/cifarsmall', test_batch_size=1000, tol=0.001)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=200, network='odenet', save='../logs/cifarsmall', test_batch_size=1000, tol=0.001)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=200, network='odenet', save='../logs/cifarsmall', test_batch_size=1000, tol=0.001)
Sequential(
  (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(64, eps=64, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (4): Conv2d(64, 128, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (5): BatchNorm2d(128, eps=128, momentum=0.1, affine=True, track_running_stats=True)
  (6): ReLU(inplace=True)
  (7): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (8): Conv2d(128, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (9): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (10): ReLU(inplace=True)
  (11): Conv2d(256, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (12): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (13): ReLU(inplace=True)
  (14): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (15): Conv2d(256, 512, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (16): BatchNorm2d(512, eps=512, momentum=0.1, affine=True, track_running_stats=True)
  (17): ReLU(inplace=True)
  (18): Flatten()
  (19): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=784, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=784, bias=True)
    )
  )
  (20): Linear(in_features=784, out_features=10, bias=True)
)
Sequential(
  (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(64, eps=64, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (4): Conv2d(64, 128, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (5): BatchNorm2d(128, eps=128, momentum=0.1, affine=True, track_running_stats=True)
  (6): ReLU(inplace=True)
  (7): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (8): Conv2d(128, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (9): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (10): ReLU(inplace=True)
  (11): Conv2d(256, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (12): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (13): ReLU(inplace=True)
  (14): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (15): Conv2d(256, 512, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (16): BatchNorm2d(512, eps=512, momentum=0.1, affine=True, track_running_stats=True)
  (17): ReLU(inplace=True)
  (18): Flatten()
  (19): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=784, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=784, bias=True)
    )
  )
  (20): Linear(in_features=784, out_features=10, bias=True)
)
Sequential(
  (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(64, eps=64, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (4): Conv2d(64, 128, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (5): BatchNorm2d(128, eps=128, momentum=0.1, affine=True, track_running_stats=True)
  (6): ReLU(inplace=True)
  (7): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (8): Conv2d(128, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (9): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (10): ReLU(inplace=True)
  (11): Conv2d(256, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (12): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (13): ReLU(inplace=True)
  (14): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (15): Conv2d(256, 512, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (16): BatchNorm2d(512, eps=512, momentum=0.1, affine=True, track_running_stats=True)
  (17): ReLU(inplace=True)
  (18): Flatten()
  (19): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=784, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=784, bias=True)
    )
  )
  (20): Linear(in_features=784, out_features=10, bias=True)
)
Sequential(
  (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(64, eps=64, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (4): Conv2d(64, 128, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (5): BatchNorm2d(128, eps=128, momentum=0.1, affine=True, track_running_stats=True)
  (6): ReLU(inplace=True)
  (7): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (8): Conv2d(128, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (9): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (10): ReLU(inplace=True)
  (11): Conv2d(256, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (12): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (13): ReLU(inplace=True)
  (14): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (15): Conv2d(256, 512, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (16): BatchNorm2d(512, eps=512, momentum=0.1, affine=True, track_running_stats=True)
  (17): ReLU(inplace=True)
  (18): Flatten()
  (19): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=784, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=784, bias=True)
    )
  )
  (20): Linear(in_features=784, out_features=10, bias=True)
)
Sequential(
  (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(64, eps=64, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (4): Conv2d(64, 128, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (5): BatchNorm2d(128, eps=128, momentum=0.1, affine=True, track_running_stats=True)
  (6): ReLU(inplace=True)
  (7): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (8): Conv2d(128, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (9): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (10): ReLU(inplace=True)
  (11): Conv2d(256, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (12): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (13): ReLU(inplace=True)
  (14): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (15): Conv2d(256, 512, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (16): BatchNorm2d(512, eps=512, momentum=0.1, affine=True, track_running_stats=True)
  (17): ReLU(inplace=True)
  (18): Flatten()
  (19): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=784, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=784, bias=True)
    )
  )
  (20): Linear(in_features=784, out_features=10, bias=True)
)
Sequential(
  (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(64, eps=64, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (4): Conv2d(64, 128, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (5): BatchNorm2d(128, eps=128, momentum=0.1, affine=True, track_running_stats=True)
  (6): ReLU(inplace=True)
  (7): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (8): Conv2d(128, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (9): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (10): ReLU(inplace=True)
  (11): Conv2d(256, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (12): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (13): ReLU(inplace=True)
  (14): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (15): Conv2d(256, 512, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (16): BatchNorm2d(512, eps=512, momentum=0.1, affine=True, track_running_stats=True)
  (17): ReLU(inplace=True)
  (18): Flatten()
  (19): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=784, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=784, bias=True)
    )
  )
  (20): Linear(in_features=784, out_features=10, bias=True)
)
Sequential(
  (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(64, eps=64, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (4): Conv2d(64, 128, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (5): BatchNorm2d(128, eps=128, momentum=0.1, affine=True, track_running_stats=True)
  (6): ReLU(inplace=True)
  (7): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (8): Conv2d(128, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (9): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (10): ReLU(inplace=True)
  (11): Conv2d(256, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (12): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (13): ReLU(inplace=True)
  (14): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (15): Conv2d(256, 512, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (16): BatchNorm2d(512, eps=512, momentum=0.1, affine=True, track_running_stats=True)
  (17): ReLU(inplace=True)
  (18): Flatten()
  (19): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=784, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=784, bias=True)
    )
  )
  (20): Linear(in_features=784, out_features=10, bias=True)
)
Sequential(
  (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(64, eps=64, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (4): Conv2d(64, 128, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (5): BatchNorm2d(128, eps=128, momentum=0.1, affine=True, track_running_stats=True)
  (6): ReLU(inplace=True)
  (7): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (8): Conv2d(128, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (9): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (10): ReLU(inplace=True)
  (11): Conv2d(256, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (12): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (13): ReLU(inplace=True)
  (14): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (15): Conv2d(256, 512, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (16): BatchNorm2d(512, eps=512, momentum=0.1, affine=True, track_running_stats=True)
  (17): ReLU(inplace=True)
  (18): Flatten()
  (19): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=784, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=784, bias=True)
    )
  )
  (20): Linear(in_features=784, out_features=10, bias=True)
)
Number of parameters: 3840202
Number of parameters: 3840202
Number of parameters: 3840202
Number of parameters: 3840202
Number of parameters: 3840202
Number of parameters: 3840202
Number of parameters: 3840202
Number of parameters: 3840202
/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example_small.py
/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example_small.py
/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example_small.py
/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example_small.py
/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example_small.py
/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example_small.py
/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example_small.py
/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example_small.py
/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example_small.py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  4 09:04:31 2021

@author: manzand
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=200)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarsmall')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(512, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 64, 3, 1),
        norm(64),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(64, 128, 4, 2, 1),
        norm(128),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(128, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.Conv2d(256, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(256, 512, 4, 2, 1),
        norm(512),
        nn.ReLU(inplace = True),
        # nn.Conv2d(512, 512, 4, 2, 1),
        # norm(512),
        # nn.ReLU(inplace = True),
        # nn.AvgPool2d(2,2),
        Flatten(),
    ]


    feature_layers = [ODEBlock(ODEfunc(512))] 
    fc_layers = [nn.Linear(512, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_small.mat",nn1)
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  4 09:04:31 2021

@author: manzand
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=200)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarsmall')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(512, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 64, 3, 1),
        norm(64),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(64, 128, 4, 2, 1),
        norm(128),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(128, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.Conv2d(256, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(256, 512, 4, 2, 1),
        norm(512),
        nn.ReLU(inplace = True),
        # nn.Conv2d(512, 512, 4, 2, 1),
        # norm(512),
        # nn.ReLU(inplace = True),
        # nn.AvgPool2d(2,2),
        Flatten(),
    ]


    feature_layers = [ODEBlock(ODEfunc(512))] 
    fc_layers = [nn.Linear(512, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_small.mat",nn1)
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  4 09:04:31 2021

@author: manzand
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=200)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarsmall')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(512, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 64, 3, 1),
        norm(64),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(64, 128, 4, 2, 1),
        norm(128),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(128, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.Conv2d(256, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(256, 512, 4, 2, 1),
        norm(512),
        nn.ReLU(inplace = True),
        # nn.Conv2d(512, 512, 4, 2, 1),
        # norm(512),
        # nn.ReLU(inplace = True),
        # nn.AvgPool2d(2,2),
        Flatten(),
    ]


    feature_layers = [ODEBlock(ODEfunc(512))] 
    fc_layers = [nn.Linear(512, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_small.mat",nn1)
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  4 09:04:31 2021

@author: manzand
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=200)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarsmall')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(512, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 64, 3, 1),
        norm(64),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(64, 128, 4, 2, 1),
        norm(128),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(128, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.Conv2d(256, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(256, 512, 4, 2, 1),
        norm(512),
        nn.ReLU(inplace = True),
        # nn.Conv2d(512, 512, 4, 2, 1),
        # norm(512),
        # nn.ReLU(inplace = True),
        # nn.AvgPool2d(2,2),
        Flatten(),
    ]


    feature_layers = [ODEBlock(ODEfunc(512))] 
    fc_layers = [nn.Linear(512, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_small.mat",nn1)
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  4 09:04:31 2021

@author: manzand
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=200)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarsmall')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(512, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 64, 3, 1),
        norm(64),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(64, 128, 4, 2, 1),
        norm(128),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(128, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.Conv2d(256, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(256, 512, 4, 2, 1),
        norm(512),
        nn.ReLU(inplace = True),
        # nn.Conv2d(512, 512, 4, 2, 1),
        # norm(512),
        # nn.ReLU(inplace = True),
        # nn.AvgPool2d(2,2),
        Flatten(),
    ]


    feature_layers = [ODEBlock(ODEfunc(512))] 
    fc_layers = [nn.Linear(512, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_small.mat",nn1)
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  4 09:04:31 2021

@author: manzand
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=200)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarsmall')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(512, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 64, 3, 1),
        norm(64),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(64, 128, 4, 2, 1),
        norm(128),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(128, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.Conv2d(256, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(256, 512, 4, 2, 1),
        norm(512),
        nn.ReLU(inplace = True),
        # nn.Conv2d(512, 512, 4, 2, 1),
        # norm(512),
        # nn.ReLU(inplace = True),
        # nn.AvgPool2d(2,2),
        Flatten(),
    ]


    feature_layers = [ODEBlock(ODEfunc(512))] 
    fc_layers = [nn.Linear(512, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_small.mat",nn1)
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  4 09:04:31 2021

@author: manzand
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=200)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarsmall')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(512, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 64, 3, 1),
        norm(64),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(64, 128, 4, 2, 1),
        norm(128),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(128, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.Conv2d(256, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(256, 512, 4, 2, 1),
        norm(512),
        nn.ReLU(inplace = True),
        # nn.Conv2d(512, 512, 4, 2, 1),
        # norm(512),
        # nn.ReLU(inplace = True),
        # nn.AvgPool2d(2,2),
        Flatten(),
    ]


    feature_layers = [ODEBlock(ODEfunc(512))] 
    fc_layers = [nn.Linear(512, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_small.mat",nn1)
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  4 09:04:31 2021

@author: manzand
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=200)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarsmall')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(512, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 64, 3, 1),
        norm(64),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(64, 128, 4, 2, 1),
        norm(128),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(128, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.Conv2d(256, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(256, 512, 4, 2, 1),
        norm(512),
        nn.ReLU(inplace = True),
        # nn.Conv2d(512, 512, 4, 2, 1),
        # norm(512),
        # nn.ReLU(inplace = True),
        # nn.AvgPool2d(2,2),
        Flatten(),
    ]


    feature_layers = [ODEBlock(ODEfunc(512))] 
    fc_layers = [nn.Linear(512, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_small.mat",nn1)
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  4 09:04:31 2021

@author: manzand
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=200)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarsmall')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(512, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 64, 3, 1),
        norm(64),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(64, 128, 4, 2, 1),
        norm(128),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(128, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.Conv2d(256, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(256, 512, 4, 2, 1),
        norm(512),
        nn.ReLU(inplace = True),
        # nn.Conv2d(512, 512, 4, 2, 1),
        # norm(512),
        # nn.ReLU(inplace = True),
        # nn.AvgPool2d(2,2),
        Flatten(),
    ]


    feature_layers = [ODEBlock(ODEfunc(512))] 
    fc_layers = [nn.Linear(512, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_small.mat",nn1)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=200, network='odenet', save='../logs/cifarsmall', test_batch_size=1000, tol=0.001)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=200, network='odenet', save='../logs/cifarsmall', test_batch_size=1000, tol=0.001)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=200, network='odenet', save='../logs/cifarsmall', test_batch_size=1000, tol=0.001)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=200, network='odenet', save='../logs/cifarsmall', test_batch_size=1000, tol=0.001)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=200, network='odenet', save='../logs/cifarsmall', test_batch_size=1000, tol=0.001)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=200, network='odenet', save='../logs/cifarsmall', test_batch_size=1000, tol=0.001)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=200, network='odenet', save='../logs/cifarsmall', test_batch_size=1000, tol=0.001)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=200, network='odenet', save='../logs/cifarsmall', test_batch_size=1000, tol=0.001)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=200, network='odenet', save='../logs/cifarsmall', test_batch_size=1000, tol=0.001)
Sequential(
  (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(64, eps=64, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (4): Conv2d(64, 128, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (5): BatchNorm2d(128, eps=128, momentum=0.1, affine=True, track_running_stats=True)
  (6): ReLU(inplace=True)
  (7): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (8): Conv2d(128, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (9): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (10): ReLU(inplace=True)
  (11): Conv2d(256, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (12): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (13): ReLU(inplace=True)
  (14): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (15): Conv2d(256, 512, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (16): BatchNorm2d(512, eps=512, momentum=0.1, affine=True, track_running_stats=True)
  (17): ReLU(inplace=True)
  (18): Flatten()
  (19): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=512, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=512, bias=True)
    )
  )
  (20): Linear(in_features=512, out_features=10, bias=True)
)
Sequential(
  (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(64, eps=64, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (4): Conv2d(64, 128, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (5): BatchNorm2d(128, eps=128, momentum=0.1, affine=True, track_running_stats=True)
  (6): ReLU(inplace=True)
  (7): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (8): Conv2d(128, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (9): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (10): ReLU(inplace=True)
  (11): Conv2d(256, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (12): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (13): ReLU(inplace=True)
  (14): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (15): Conv2d(256, 512, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (16): BatchNorm2d(512, eps=512, momentum=0.1, affine=True, track_running_stats=True)
  (17): ReLU(inplace=True)
  (18): Flatten()
  (19): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=512, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=512, bias=True)
    )
  )
  (20): Linear(in_features=512, out_features=10, bias=True)
)
Sequential(
  (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(64, eps=64, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (4): Conv2d(64, 128, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (5): BatchNorm2d(128, eps=128, momentum=0.1, affine=True, track_running_stats=True)
  (6): ReLU(inplace=True)
  (7): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (8): Conv2d(128, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (9): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (10): ReLU(inplace=True)
  (11): Conv2d(256, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (12): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (13): ReLU(inplace=True)
  (14): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (15): Conv2d(256, 512, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (16): BatchNorm2d(512, eps=512, momentum=0.1, affine=True, track_running_stats=True)
  (17): ReLU(inplace=True)
  (18): Flatten()
  (19): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=512, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=512, bias=True)
    )
  )
  (20): Linear(in_features=512, out_features=10, bias=True)
)
Sequential(
  (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(64, eps=64, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (4): Conv2d(64, 128, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (5): BatchNorm2d(128, eps=128, momentum=0.1, affine=True, track_running_stats=True)
  (6): ReLU(inplace=True)
  (7): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (8): Conv2d(128, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (9): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (10): ReLU(inplace=True)
  (11): Conv2d(256, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (12): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (13): ReLU(inplace=True)
  (14): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (15): Conv2d(256, 512, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (16): BatchNorm2d(512, eps=512, momentum=0.1, affine=True, track_running_stats=True)
  (17): ReLU(inplace=True)
  (18): Flatten()
  (19): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=512, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=512, bias=True)
    )
  )
  (20): Linear(in_features=512, out_features=10, bias=True)
)
Sequential(
  (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(64, eps=64, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (4): Conv2d(64, 128, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (5): BatchNorm2d(128, eps=128, momentum=0.1, affine=True, track_running_stats=True)
  (6): ReLU(inplace=True)
  (7): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (8): Conv2d(128, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (9): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (10): ReLU(inplace=True)
  (11): Conv2d(256, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (12): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (13): ReLU(inplace=True)
  (14): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (15): Conv2d(256, 512, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (16): BatchNorm2d(512, eps=512, momentum=0.1, affine=True, track_running_stats=True)
  (17): ReLU(inplace=True)
  (18): Flatten()
  (19): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=512, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=512, bias=True)
    )
  )
  (20): Linear(in_features=512, out_features=10, bias=True)
)
Sequential(
  (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(64, eps=64, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (4): Conv2d(64, 128, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (5): BatchNorm2d(128, eps=128, momentum=0.1, affine=True, track_running_stats=True)
  (6): ReLU(inplace=True)
  (7): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (8): Conv2d(128, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (9): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (10): ReLU(inplace=True)
  (11): Conv2d(256, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (12): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (13): ReLU(inplace=True)
  (14): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (15): Conv2d(256, 512, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (16): BatchNorm2d(512, eps=512, momentum=0.1, affine=True, track_running_stats=True)
  (17): ReLU(inplace=True)
  (18): Flatten()
  (19): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=512, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=512, bias=True)
    )
  )
  (20): Linear(in_features=512, out_features=10, bias=True)
)
Sequential(
  (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(64, eps=64, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (4): Conv2d(64, 128, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (5): BatchNorm2d(128, eps=128, momentum=0.1, affine=True, track_running_stats=True)
  (6): ReLU(inplace=True)
  (7): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (8): Conv2d(128, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (9): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (10): ReLU(inplace=True)
  (11): Conv2d(256, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (12): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (13): ReLU(inplace=True)
  (14): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (15): Conv2d(256, 512, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (16): BatchNorm2d(512, eps=512, momentum=0.1, affine=True, track_running_stats=True)
  (17): ReLU(inplace=True)
  (18): Flatten()
  (19): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=512, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=512, bias=True)
    )
  )
  (20): Linear(in_features=512, out_features=10, bias=True)
)
Sequential(
  (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(64, eps=64, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (4): Conv2d(64, 128, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (5): BatchNorm2d(128, eps=128, momentum=0.1, affine=True, track_running_stats=True)
  (6): ReLU(inplace=True)
  (7): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (8): Conv2d(128, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (9): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (10): ReLU(inplace=True)
  (11): Conv2d(256, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (12): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (13): ReLU(inplace=True)
  (14): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (15): Conv2d(256, 512, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (16): BatchNorm2d(512, eps=512, momentum=0.1, affine=True, track_running_stats=True)
  (17): ReLU(inplace=True)
  (18): Flatten()
  (19): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=512, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=512, bias=True)
    )
  )
  (20): Linear(in_features=512, out_features=10, bias=True)
)
Sequential(
  (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(64, eps=64, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (4): Conv2d(64, 128, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (5): BatchNorm2d(128, eps=128, momentum=0.1, affine=True, track_running_stats=True)
  (6): ReLU(inplace=True)
  (7): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (8): Conv2d(128, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (9): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (10): ReLU(inplace=True)
  (11): Conv2d(256, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (12): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (13): ReLU(inplace=True)
  (14): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (15): Conv2d(256, 512, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (16): BatchNorm2d(512, eps=512, momentum=0.1, affine=True, track_running_stats=True)
  (17): ReLU(inplace=True)
  (18): Flatten()
  (19): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=512, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=512, bias=True)
    )
  )
  (20): Linear(in_features=512, out_features=10, bias=True)
)
Number of parameters: 3828506
Number of parameters: 3828506
Number of parameters: 3828506
Number of parameters: 3828506
Number of parameters: 3828506
Number of parameters: 3828506
Number of parameters: 3828506
Number of parameters: 3828506
Number of parameters: 3828506
Epoch 0000 | Time 1.313 (1.313) | NFE-F 32.0 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0000 | Time 1.313 (1.313) | NFE-F 32.0 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0000 | Time 1.313 (1.313) | NFE-F 32.0 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0000 | Time 1.313 (1.313) | NFE-F 32.0 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0000 | Time 1.313 (1.313) | NFE-F 32.0 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0000 | Time 1.313 (1.313) | NFE-F 32.0 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0000 | Time 1.313 (1.313) | NFE-F 32.0 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0000 | Time 1.313 (1.313) | NFE-F 32.0 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0000 | Time 1.313 (1.313) | NFE-F 32.0 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0001 | Time 1.056 (0.928) | NFE-F 26.6 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0001 | Time 1.056 (0.928) | NFE-F 26.6 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0001 | Time 1.056 (0.928) | NFE-F 26.6 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0001 | Time 1.056 (0.928) | NFE-F 26.6 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0001 | Time 1.056 (0.928) | NFE-F 26.6 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0001 | Time 1.056 (0.928) | NFE-F 26.6 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0001 | Time 1.056 (0.928) | NFE-F 26.6 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0001 | Time 1.056 (0.928) | NFE-F 26.6 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0001 | Time 1.056 (0.928) | NFE-F 26.6 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
/home/manzand/Documents/Python/neuralODE_examples/cifar/odenet_cifar_example_small.py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  4 09:04:31 2021

@author: manzand
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jan 19 15:10:31 2021

@author: manzand
"""

import os
import argparse
import logging
import time
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader
import torchvision.datasets as datasets
import torchvision.transforms as transforms
from scipy.io import savemat

parser = argparse.ArgumentParser()
parser.add_argument('--network', type=str, choices=['resnet', 'odenet'], default='odenet')
parser.add_argument('--tol', type=float, default=1e-3)
parser.add_argument('--adjoint', type=eval, default=False, choices=[True, False])
parser.add_argument('--downsampling-method', type=str, default='conv', choices=['conv', 'res'])
parser.add_argument('--nepochs', type=int, default=200)
parser.add_argument('--data_aug', type=eval, default=False, choices=[True, False])
parser.add_argument('--lr', type=float, default=0.01)
parser.add_argument('--batch_size', type=int, default=128)
parser.add_argument('--test_batch_size', type=int, default=1000)

parser.add_argument('--save', type=str, default='../logs/cifarsmall')
parser.add_argument('--debug', action='store_true')
parser.add_argument('--gpu', type=int, default=0)
args = parser.parse_args()

if args.adjoint:
    from torchdiffeq import odeint_adjoint as odeint
else:
    from torchdiffeq import odeint


def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)


def conv1x1(in_planes, out_planes, stride=1):
    """1x1 convolution"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)


def norm(dim):
    return nn.BatchNorm2d(min(512, dim), dim)


class ConcatConv2d(nn.Module):

    def __init__(self, dim_in, dim_out, ksize=3, stride=1, padding=0, dilation=1, groups=1, bias=True, transpose=False):
        super(ConcatConv2d, self).__init__()
        module = nn.ConvTranspose2d if transpose else nn.Conv2d
        self._layer = module(
            dim_in + 1, dim_out, kernel_size=ksize, stride=stride, padding=padding, dilation=dilation, groups=groups,
            bias=bias
        )

    def forward(self, t, x):
        tt = torch.ones_like(x[:, :1, :, :]) * t
        ttx = torch.cat([tt, x], 1)
        return self._layer(ttx)


class ODEfunc(nn.Module):

    def __init__(self,dim):
        super(ODEfunc, self).__init__()
        self.fc1 = nn.Linear(dim,16)
        self.fc2 = nn.Linear(16, dim)
        self.nfe = 0

    def forward(self, t, x):
        self.nfe += 1
        out = self.fc1(x)
        out = self.fc2(out)
        return out


class ODEBlock(nn.Module):

    def __init__(self, odefunc):
        super(ODEBlock, self).__init__()
        self.odefunc = odefunc
        self.integration_time = torch.tensor([0, 1]).float()

    def forward(self, x):
        self.integration_time = self.integration_time.type_as(x)
        out = odeint(self.odefunc, x, self.integration_time, rtol=args.tol, atol=args.tol)
        return out[1]

    @property
    def nfe(self):
        return self.odefunc.nfe

    @nfe.setter
    def nfe(self, value):
        self.odefunc.nfe = value


class Flatten(nn.Module):

    def __init__(self):
        super(Flatten, self).__init__()

    def forward(self, x):
        shape = torch.prod(torch.tensor(x.shape[1:])).item()
        return x.view(-1, shape)


class RunningAverageMeter(object):
    """Computes and stores the average and current value"""

    def __init__(self, momentum=0.99):
        self.momentum = momentum
        self.reset()

    def reset(self):
        self.val = None
        self.avg = 0

    def update(self, val):
        if self.val is None:
            self.avg = val
        else:
            self.avg = self.avg * self.momentum + val * (1 - self.momentum)
        self.val = val


def get_cifar_loaders(data_aug=False, batch_size=32, test_batch_size=1000, perc=1.0):
    if data_aug:
        transform_train = transforms.Compose([
            transforms.RandomCrop(28, padding=4),
            transforms.ToTensor(),
        ])
    else:
        transform_train = transforms.Compose([
            transforms.ToTensor(),
        ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
    ])

    train_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_train), batch_size=batch_size,
        shuffle=True, num_workers=2, drop_last=True
    )

    train_eval_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=True, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    test_loader = DataLoader(
        datasets.CIFAR10(root='.data/cifar10', train=False, download=True, transform=transform_test),
        batch_size=test_batch_size, shuffle=False, num_workers=2, drop_last=True
    )

    return train_loader, test_loader, train_eval_loader


def inf_generator(iterable):
    """Allows training with DataLoaders in a single infinite loop:
        for i, (x, y) in enumerate(inf_generator(train_loader)):
    """
    iterator = iterable.__iter__()
    while True:
        try:
            yield iterator.__next__()
        except StopIteration:
            iterator = iterable.__iter__()


def learning_rate_with_decay(batch_size, batch_denom, batches_per_epoch, boundary_epochs, decay_rates):
    initial_learning_rate = args.lr * batch_size / batch_denom

    boundaries = [int(batches_per_epoch * epoch) for epoch in boundary_epochs]
    vals = [initial_learning_rate * decay for decay in decay_rates]

    def learning_rate_fn(itr):
        lt = [itr < b for b in boundaries] + [True]
        i = np.argmax(lt)
        return vals[i]

    return learning_rate_fn


def one_hot(x, K):
    return np.array(x[:, None] == np.arange(K)[None, :], dtype=int)


def accuracy(model, dataset_loader):
    total_correct = 0
    for x, y in dataset_loader:
        x = x.to(device)
        y = one_hot(np.array(y.numpy()), 10)

        target_class = np.argmax(y, axis=1)
        predicted_class = np.argmax(model(x).cpu().detach().numpy(), axis=1)
        total_correct += np.sum(predicted_class == target_class)
    return total_correct / len(dataset_loader.dataset)


def count_parameters(model):
    return sum(p.numel() for p in model.parameters() if p.requires_grad)


def makedirs(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)


def get_logger(logpath, filepath, package_files=[], displaying=True, saving=True, debug=False):
    logger = logging.getLogger()
    if debug:
        level = logging.DEBUG
    else:
        level = logging.INFO
    logger.setLevel(level)
    if saving:
        info_file_handler = logging.FileHandler(logpath, mode="a")
        info_file_handler.setLevel(level)
        logger.addHandler(info_file_handler)
    if displaying:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(level)
        logger.addHandler(console_handler)
    logger.info(filepath)
    with open(filepath, "r") as f:
        logger.info(f.read())

    for f in package_files:
        logger.info(f)
        with open(f, "r") as package_f:
            logger.info(package_f.read())

    return logger


if __name__ == '__main__':

    makedirs(args.save)
    logger = get_logger(logpath=os.path.join(args.save, 'logs'), filepath=os.path.abspath(__file__))
    logger.info(args)

    device = torch.device('cuda:' + str(args.gpu) if torch.cuda.is_available() else 'cpu')

    is_odenet = args.network == 'odenet'

    downsampling_layers = [
        nn.Conv2d(3, 64, 3, 1),
        norm(64),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(64, 128, 4, 2, 1),
        norm(128),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(128, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.Conv2d(256, 256, 4, 2, 1),
        norm(256),
        nn.ReLU(inplace = True),
        nn.AvgPool2d(2,1),
        nn.Conv2d(256, 512, 4, 2, 1),
        norm(512),
        nn.ReLU(inplace = True),
        # nn.Conv2d(512, 512, 4, 2, 1),
        # norm(512),
        # nn.ReLU(inplace = True),
        # nn.AvgPool2d(2,2),
        Flatten(),
    ]


    feature_layers = [ODEBlock(ODEfunc(512))] 
    fc_layers = [nn.Linear(512, 10)]

    model = nn.Sequential(*downsampling_layers, *feature_layers, *fc_layers).to(device)

    logger.info(model)
    logger.info('Number of parameters: {}'.format(count_parameters(model)))

    criterion = nn.CrossEntropyLoss().to(device)

    train_loader, test_loader, train_eval_loader = get_cifar_loaders(
        args.data_aug, args.batch_size, args.test_batch_size
    )

    data_gen = inf_generator(train_loader)
    batches_per_epoch = len(train_loader)

    lr_fn = learning_rate_with_decay(
        args.batch_size, batch_denom=128, batches_per_epoch=batches_per_epoch, boundary_epochs=[60, 100, 140],
        decay_rates=[1, 0.1, 0.01, 0.001]
    )

    optimizer = torch.optim.SGD(model.parameters(), lr=args.lr, momentum=0.9)

    best_acc = 0
    batch_time_meter = RunningAverageMeter()
    f_nfe_meter = RunningAverageMeter()
    b_nfe_meter = RunningAverageMeter()
    end = time.time()

    for itr in range(args.nepochs * batches_per_epoch):

        for param_group in optimizer.param_groups:
            param_group['lr'] = lr_fn(itr)

        optimizer.zero_grad()
        x, y = data_gen.__next__()
        x = x.to(device)
        y = y.to(device)
        logits = model(x)
        loss = criterion(logits, y)

        if is_odenet:
            nfe_forward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        loss.backward()
        optimizer.step()

        if is_odenet:
            nfe_backward = feature_layers[0].nfe
            feature_layers[0].nfe = 0

        batch_time_meter.update(time.time() - end)
        if is_odenet:
            f_nfe_meter.update(nfe_forward)
            b_nfe_meter.update(nfe_backward)
        end = time.time()

        if itr % batches_per_epoch == 0:
            with torch.no_grad():
                train_acc = accuracy(model, train_eval_loader)
                val_acc = accuracy(model, test_loader)
                if val_acc > best_acc:
                    torch.save({'state_dict': model.state_dict(), 'args': args}, os.path.join(args.save, 'model.pth'))
                    best_acc = val_acc
                if best_acc > 0.85 and train_acc > 0.85:
                    break
                logger.info(
                    "Epoch {:04d} | Time {:.3f} ({:.3f}) | NFE-F {:.1f} | NFE-B {:.1f} | "
                    "Train Acc {:.4f} | Test Acc {:.4f}".format(
                        itr // batches_per_epoch, batch_time_meter.val, batch_time_meter.avg, f_nfe_meter.avg,
                        b_nfe_meter.avg, train_acc, val_acc
                    )
                )
    names = []
    params = []
    for name,param in model.named_parameters():
        names.append(name)
        params.append(param.detach().numpy())
    nn1 = dict({'Wb':params,'names':names})
    for name,param in model.named_buffers():
        names.append(name)
        params.append(param.detach().numpy())
    savemat("odecnn_cifar_small.mat",nn1)
Namespace(adjoint=False, batch_size=128, data_aug=False, debug=False, downsampling_method='conv', gpu=0, lr=0.01, nepochs=200, network='odenet', save='../logs/cifarsmall', test_batch_size=1000, tol=0.001)
Sequential(
  (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1))
  (1): BatchNorm2d(64, eps=64, momentum=0.1, affine=True, track_running_stats=True)
  (2): ReLU(inplace=True)
  (3): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (4): Conv2d(64, 128, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (5): BatchNorm2d(128, eps=128, momentum=0.1, affine=True, track_running_stats=True)
  (6): ReLU(inplace=True)
  (7): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (8): Conv2d(128, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (9): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (10): ReLU(inplace=True)
  (11): Conv2d(256, 256, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (12): BatchNorm2d(256, eps=256, momentum=0.1, affine=True, track_running_stats=True)
  (13): ReLU(inplace=True)
  (14): AvgPool2d(kernel_size=2, stride=1, padding=0)
  (15): Conv2d(256, 512, kernel_size=(4, 4), stride=(2, 2), padding=(1, 1))
  (16): BatchNorm2d(512, eps=512, momentum=0.1, affine=True, track_running_stats=True)
  (17): ReLU(inplace=True)
  (18): Flatten()
  (19): ODEBlock(
    (odefunc): ODEfunc(
      (fc1): Linear(in_features=512, out_features=16, bias=True)
      (fc2): Linear(in_features=16, out_features=512, bias=True)
    )
  )
  (20): Linear(in_features=512, out_features=10, bias=True)
)
Number of parameters: 3828506
Epoch 0000 | Time 1.143 (1.143) | NFE-F 32.0 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0001 | Time 1.238 (0.846) | NFE-F 26.5 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0002 | Time 1.165 (0.849) | NFE-F 26.3 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0003 | Time 1.048 (0.828) | NFE-F 20.5 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0004 | Time 1.173 (0.828) | NFE-F 20.3 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0005 | Time 1.247 (0.854) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0006 | Time 1.291 (0.852) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0007 | Time 1.128 (0.829) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0008 | Time 1.402 (0.824) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0009 | Time 1.177 (0.858) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0010 | Time 1.188 (0.837) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0011 | Time 1.349 (0.972) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0012 | Time 1.054 (0.823) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0013 | Time 1.220 (0.842) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0014 | Time 1.070 (0.857) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0015 | Time 1.190 (0.831) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0016 | Time 1.463 (0.917) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0017 | Time 1.059 (0.841) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0018 | Time 1.257 (0.875) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0019 | Time 1.191 (0.822) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0020 | Time 1.096 (0.903) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0021 | Time 1.034 (0.844) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0022 | Time 1.255 (0.857) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0023 | Time 1.276 (0.955) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0024 | Time 1.229 (0.876) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0025 | Time 1.092 (0.837) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0026 | Time 1.274 (0.861) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0027 | Time 0.662 (0.515) | NFE-F 20.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0028 | Time 0.569 (0.418) | NFE-F 16.5 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0029 | Time 0.577 (0.429) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0030 | Time 0.593 (0.420) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0031 | Time 0.613 (0.420) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0032 | Time 0.566 (0.414) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0033 | Time 0.643 (0.452) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0034 | Time 0.647 (0.432) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0035 | Time 0.714 (0.433) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0036 | Time 0.583 (0.431) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0037 | Time 0.597 (0.446) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0038 | Time 0.583 (0.424) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0039 | Time 0.619 (0.434) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0040 | Time 0.566 (0.420) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0041 | Time 0.643 (0.421) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0042 | Time 0.629 (0.419) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0043 | Time 0.671 (0.439) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0044 | Time 0.628 (0.435) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0045 | Time 0.611 (0.423) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0046 | Time 0.618 (0.419) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0047 | Time 0.597 (0.424) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0048 | Time 0.612 (0.437) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0049 | Time 0.601 (0.428) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0050 | Time 0.668 (0.435) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0051 | Time 0.647 (0.449) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0052 | Time 0.640 (0.429) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0053 | Time 0.636 (0.425) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
Epoch 0054 | Time 0.604 (0.445) | NFE-F 14.2 | NFE-B 0.0 | Train Acc 0.1000 | Test Acc 0.1000
